# 第2章-C语言基础思维模型

Hi，希望你已经好好读过了第0章和第1章，他们虽然不是关于变成本身的内容，但是非常重要。

&nbsp;

之后的第2章和第3章，将会带你初步了解C语言的重要的语法，带你度过学习C语言的最初的阶段，能够基本编出简单的程序。

&nbsp;

## 2.1 声明-初步接触(1)

我们首先再复习一下，程序是干什么的：

**程序**，就是指挥CPU如何进行运作的一系列命令。这一系列的命令的主要作用就是，**数据操作**的操作包括算术运算或其他操作，例如加减乘除，复制读写。那么本质上而言其实我们在做的事情无非还是一个计算器的活路，不过是一个智能的，强大的计算器。

所以数据的处理其实就是**程序**的主要目的。我们对数这个概念在数学上的认识无非就是：自然数，整数，有理数，实数，复数。然而我们在计算机中，需要面对不同的情况选择不同的**数据类型**。

&nbsp;

### 单位基础

计算机中，一个二进制数的位数或者长度，我们称之为**位** bit，例如1001是一个4位的，或者叫4bit的二进制数。

我们另外有一个单位叫做**字节** Byte，换算关系是8个Bit等同于一个Byte。

一般而言在技术探讨时字节数是整数，很少说这个是1.5Byte的二进制数。

然后就有我们常见的单位了KB，MB，GB，TB，他们都是Byte的倍数，依次扩大1024倍。

<img src=".\引用图片\001.png" style="float:left;" width="300" />

&nbsp;

### 📄任务2.1.1-数学运算(单位部分)

请你按照上述的知识进行一些数学运算。

上面讲的很水，因为计算机单位基本上已经成为现代计算机使用者的常识了。如果不会的话，麻烦自己学习一下。

&nbsp;

### 数据类型

**数据类型**，在计算机中主要是指使用了不同方法来进行储存的数据。不同的数据类型在内存上的记录方法和占用空间不太一样。

需要注意的一个前提是，内存中的数据，按照计算机的惯例，使用0和1来进行表达。如下的讨论，都是如何使用0和1在内存中表达不同类型的数据！

&nbsp;

#### 无符号整数

我们目前最能够用直觉想到的就是在内存中将十进制的正数直接转换成二进制。直接将这种二进制写到内存上的数据就是非负的整数的表达方法。我们更加专业的说，这个叫做**无符号整数**。

<img src=".\引用图片\002.png" style="float:left;" width="300" />

在实际应用中计算机内存没有办法无穷大，所以我们不能够将任意的数都转换成二进制。同时，在硬件的设计要求下，我们最好将所有的数据的二进制长度规定成一个固定值（具体是什么固定值我们会后面讲解）。如果二进制长度固定，那么这个二进制数能够表达的最大和最小的范围也就固定了。

因为位数固定，无法表达环外的数，一旦超过了最大值，更高的二进制位没有办法被保存下来，因此会被抛弃，数据也就回到了一个很小的值上面。这种情况我们称之为**上溢**，反之称为**下溢**。因此，我们常常会在计算机的讲解中，将整数都描述成一个数环。

例如下图是一个四位的**无符号整数**的数环。

<p align="center">
  <img src=".\引用图片\003.png" width="400" />
</p>
&nbsp;


#### 有符号整数

那么肯定就有人想问了，有符号的整数怎么办？这个问题的答案第一眼看上去非常怪异，但是实际上背后就是一种数学原理。

在位数固定的情况下，我们将最前面一位（也称作最高位）规定为**符号位**。如果符号位是1，则说明这个数据是负数，反之是负数。

需要注意的是，符号位为0的时候，我们就将数据当成无符号整数一模一样看待，进行二进制的运算；符号位为1的时候，则需要进行一番转换之后找到对应的正数的表达模式，这个转换方法叫做取**补码**：将0和1互换，然后再加一。

下面有一些对应的有符号整数的解读案例。全部都是基于长度为8位的二进制整数。

<img src=".\引用图片\004.png" style="float:left;" width="600" />

需要注意的是，**补码**这个过程可逆，即一个数补码的补码是自己（你还可以发现一个快速运算补码的方式）。

<img src=".\引用图片\005.png" style="float:left;" width="700" />

&nbsp;

我们可以看到四位的**有符号整数**数环如图，需要注意的是，补码的数环中上下溢出的位置发生了一些变换。

<p align="center">
  <img src=".\引用图片\006.png" width="400" />
</p>



### 📄任务2.1.2-数学运算(整数部分)

请你按照上述的知识进行一些数学运算。

&nbsp;

#### 补码的妙处

可能补码这个定义会感到神奇，但是你可以在任务2.1.1中发现一个神奇的事情：补码表示的负数和一个正数相加之后，仍然保持数学上的成立。

<p align="center">
  <img src=".\引用图片\008.png" width="600" />
</p>
&nbsp;


这个数学运算的成立不是随便就凑得出来的。例如我们规定，第一位当作符号位，剩下的位数就直接进行二进制的转换来表示大小，这样的一个体系没有办法直接进行正负数之间的加法运算。你可以自己尝试一下。

<p align="center">
  <img src=".\引用图片\007.png" width="400" />
</p>
&nbsp;


补码能够运算上成立，我们可以从多个角度上进行思考。

第一个角度是从相减借位的思路上进行思考。我们当然知道二进制位全部是0的时候就是0，然后我们也知道一个数，例如说2，那么我们试着竖式运算0减2。不论如何，这个结论就是-2。

相减之后，需要一直一直向前面借位，直到碰到我们规定的位数长度。虽然结论有些怪异，但是你会发现你就得到了2的**补码**，这个也就可以拿来表达-2。

<p align="center">
  <img src=".\引用图片\009.png" width="600" />
</p>
&nbsp;


另外一个角度就是从数环上来思考。我们拿四位整数来进行思考，无符号整数到有符号整数的过渡中，15对应-1，14对应-2……你会发现只有**补码**这样的规定会让数环连续而且紧凑。反观我们刚才规定的规则，你会发现出现了两个0，一个“正0”一个“负0”，这个样子就破坏了数环的紧凑型，也难怪会在正数和负数之间加减会导致结论的错误。

<p align="center">
  <img src=".\引用图片\006.png" width="350" />
  <img src=".\引用图片\010.png" width="350" />
</p>
&nbsp;


如果仔细思考，在四位二进制数中，两个互为补码的数在广义上是关于16互余的。这一点数学上的“巧合”保证了加减运算在这个体系下仍然成立。

&nbsp;

#### 浮点数

我们整数的规定中，无形增加了如下的一些限制：最大值和最小值的规定，而且表达的内容必须是整数。

但是如果我想要表达一个小数呢？

其中一个表达方法是，将二进制的小数点向前移动，但是你很快会发现一个悲惨的事情：在位数固定的时候，如果你想要提高表达精度，那么这个数能够表达的最大值和最小值就会不断缩小，这个体系完全无法同时容纳精度较高的小数和比较大的数。这种表达方式就是**定点数**，即小数点位置固定的计数方法的局限性了。

<img src=".\引用图片\011.png" style="float:left;" width="400" />

&nbsp;

既然你知道了问题所在，解决方法也就呼之欲出了：你早就学过了科学计数法。科学计数法的思路就是不管数多大或者多小，换成一个固定大小的数，然后后面一个次方搞定问题。不过现在的科学计数法换成了二进制上面进行表示。这种科学计数法一般的方法在计算机中也被称为**浮点数**。

<img src=".\引用图片\012.png" style="float:left;" width="150" />

&nbsp;

按照IEEE 754标准规定，我们将32位或者64位的二进制数划分成如下的三个区域来表示浮点数。需要注意的是，这里的讲解并不完整，不过那些附加的规定对于我们现在并不重要，具体可以自己搜一些资料进行了解。

<img src=".\引用图片\013.png" style="float:left;" width="500" />

&nbsp;

如下是一些运算的案例。

<img src=".\引用图片\014.png" style="float:left;" width="500" />

&nbsp;

### 📄任务2.1.3-数学运算(浮点数部分)

既然学习了浮点数，我们也就来思考一下浮点数的运算吧！

&nbsp;

#### 字符

既然数都获得了他们自己的表达方式了，我们是不是也应该为字母或者字符准备一个表达方式？

当然，我们没有办法进行一个什么精巧的数学的换算，只能强行人为规定。人们依照常用的字符，规定出了一个表格，这个表格叫做美国信息交换标准代码(ASCII)。

<p align="center">
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/USASCII_code_chart.png/1024px-USASCII_code_chart.png" width="500" />
  <p align="center">This work is in the public domain, source from Wikipedia</p>
</p>

上面这个表格有一点不太易懂，但是我也找不到其他版权允许引用的。具体的解释请看维基百科[这个链接](https://zh.wikipedia.org/zh-cn/ASCII)中的ASCII的具体列表。

&nbsp;

可以发现的是，ASCII仅仅使用了7位二进制数字表达出了这些字符，他们是一一映射的关系。不过，计算机设计中特别喜欢凑2的次方的，因此最终ASCII表达出来的字母是占有8位二进制数字长度。

ASCII表最开始的一些内容不是可以显示的字符。当年发明ASCII的一大目的是为了远程控制网络打印机，前面的一些字符主要是用于打印机的控制。现在我们还在使用其中很小的一部分内容，例如说回车，空格，换行等等。这些字符仍然可以在**控制台应用程序**中得到展现，我们之后会讲到他们。

&nbsp;

除了ASCII，我们还有更多的编码标准，能容纳更多的字符，例如说ASCII扩展，UTF-8，GBK等等，这些我们就不一一了解了。ASCII是C编程中经常遇到的内容。

&nbsp;

> ℹ 信息：其他的数据呢？
>
> 作为一个好奇心强的人，你肯定会问，那图片呢？那音乐呢？那打游戏的时候的3D模型呢？
>
> 这些内容都不是一个最为基础的计算机程序需要处理的内容了，因此C语言并不原生支持他们。可能你会感到诧异，不过你要知道早期的计算机使用者也觉得鼠标不是一个基础的计算机需要的东西。
>
> 这些其他的数据，都有着自己的编码方式，他们为了不同的目的设计编码模式，用各自的软件进行解读。如果你有兴趣的话，可以在这里阅读一下一些文件的编码方式（欣赏一下就好哈哈哈）：
>
> https://zh.wikipedia.org/zh-cn/JPEG
>
> https://zh.wikipedia.org/zh-cn/MPEG-2#%E6%A0%87%E5%87%86%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82
>
> &nbsp;
>
> 抛开上面这些基本没法看懂的天书不谈，这里涉及到了第0章挖下的一个坑了：关于文件格式的小知识。
>
> 我们平常接触的文件的后缀名例如exe，txt，jpg，mp3是表达文件不同的编码方式。后缀名的作用是，向操作系统说明，用什么软件来打开这个文件，即用什么软件来解读这个数据。需要注意的是，不管是图片还是文字，数据最终都是二进制的0和1，（在没有进行专业训练的情况下）你无法看出他们在二进制上的区别。因此，重要的问题在于，究竟用什么软件，用什么方式去解读这些二进制数据。
>
> 如果你愿意，你可以将一张图片用文本编辑器打开，但是你只会看到一堆乱码而不是一张图片。甚至你可以将一张图片按照进制转换，换算成一个巨大的数。但是乱码和无意义的数有什么用处呢？如果使用了错误的解读方法，你无法理解里面的信息。
>
> 我们之前第0章同时遇到了不少的格式问题，例如说txt后缀名直接更改为bat或者c是可以的，但是mp4需要用软件转换出avi。
>
> 前者只是告诉操作系统更换了一个软件来打开它，数据的编码方式是不变的（都是文本）。后者则是更改了编码方式，对应地改变了后缀名，用来告诉系统解读方法的变化。

如上就是C语言的**数据类型**的基础知识。

&nbsp;

### 📄任务2.1.4-数据格式概念(选做)

这里是一些数据格式的基础概念，之所以是选做，是因为和C编程没有关系。但是我希望你能够进行思考并且回答一下问题。

&nbsp;

### 声明的语法讲解

你会发现之前那些东西结果还是空谈，觉得简单的很。不要着急，马上就要进入代码的讲解部分了，保证让你不再无聊。我们现在就来讲解C语言中怎么来表示他们。现在我们就入手语法部分。

&nbsp;

我们在C语言中，使用**变量**来保存数据。这些**变量**在内存中对应了空间，有各自的**数据类型**。

我们通过**声明**（declaration）来获得新的**变量**。**声明**不是一种**语句**（statement），但是它也是用分号结束的。**声明**就是我们即将仔细研究的内容。

&nbsp;

例如说我们想要获得不同的数据类型的变量，就需要按照下面这种格式来**声明**他们。声明之后，你就获得了一个变量，其中前面的部分指定了变量的数据类型，后面的部分指定了变量的名字。

```c
int a;                      //这是一个有符号的整数类型的变量，名字是a
signed int b;               //这是一个有符号的整数类型的变量，名字是b
unsigned int c;             //这是一个无符号的整数类型的变量，名字是c
long d;                     //这是一个有符号的整数类型的变量，且为长整型，名字是d
char e;                     //这是一个(符号未知的)字符类型的变量，名字是e*
float f;                    //这是一个有符号的浮点类型的变量，且为单精度浮点数，名字是f
double g;                   //这是一个有符号的字符类型的变量，且为双精度浮点数，名字是g

//*直觉上说，字符怎么能有符号呢？其实还真有，但是你不需要太关注
```

上面目前只是例子的列举，有一些东西你看不懂，无所谓，我们马上仔细研究。

我们来分开看前后两个部分。

&nbsp;

#### 声明前半部分：声明说明符 declaration-specifiers

前面一部分，叫做这个**声明**中的**声明说明符**（declaration-specifiers）。

<p align="center">
  <img src=".\引用图片\015.png" width="300" />
</p>
&nbsp;


目前我们接触的**声明说明符**的组成要素都是**类型说明符**（type-specifiers），且目前我们接触的**类型说明符**都是C中的**关键字**（keywords）。

目前我们需要知道的**类型说明符**的关键字有：

```c
char short int long signed unsigned float double
```

&nbsp;

**声明说明符**可以是单个**类型说明符**，或者多个**类型说明符**的组合。

<p align="center">
  <img src=".\引用图片\016.png" width="300" />
</p>
&nbsp;

不同的**声明说明符**就会对应在内存中预定不同**数据类型**的内存空间。虽然**类型说明符**看上去可以有很多组合，但是实际上组合出来有效的**声明说明符**只有如下的列表中所示的内容：

```c
//最终对应字符的声明说明符有（char 是 character 的简写）
char
//最终对应整数类型的声明说明符有（int 是 integer 的简写）
short
int
long
long long
//最终对应浮点数类型的声明说明符有（float 即代表浮点数）
float
double
```

1. 除了浮点数类型的**声明说明符**以外，其他的都可以在前面再附加有符号或者无符号的**类型说明符**（signed, unsigned）以组成新的**声明说明符**，例如unsigned long long。

   对于**整数类型**的声明，默认都是有符号的，因此只有需要无符号整数的时候才必须在前面附加unsigned类型说明符。

   对于**字符**的声明，符号类型未知。

2. 对于属于同一个类型的**声明说明符**，例如short，int和long之间，内部的区别就是占据内存空间大小的区别。

   对于**浮点数类型**的声明，float和double分别对应的就是之前的IEEE 754标准中占有32和64位内存空间的浮点数，分别叫做单精度浮点数和双精度浮点数。

   对于**整数类型**的声明，各个声明说明符的占据空间不定，随机器和系统可能变化。需要注意的是，所有的机器仅仅保证long long不短于long不短于int不短于short，占有长度有可能存在等同的情况。

   (之后会有一个练习题来进行探索他们究竟占多长的内存)

3. 由于同一个类型中会出现不同的声明说明符，叫全称会很累人，因此我们之后约定就将对应的**声明说明符**作为数据类型的名字代表。例如说之后说“一个unsigned int类型的变量”，就是指，他是一个无符号的整型变量，他的声明说明符是unsigned int。

&nbsp;

> ℹ 信息
>
> char的有符号和无符号问题
>
> 你如果“正常地”使用char类型的变量，是不会遇到符号问题的。只有在非常稀有的情况中，你出于性能或者节省空间的原因（常常出现在单片机编程中），要用char这个类型的变量来装整数类型的数（因为char只有一个Byte即8个Bit的大小，占用空间很小）才会碰见有符号还是无符号的类型这个难题。
>
> 因此在这种情况下，请要清楚的指定char是signed还是unsigned的。但是我们用存储字符的时候使用char就够了。

&nbsp;

#### 声明后半部分：标识符 identifier

**标识符**，其实就是“名字”的正式说法。一个变量或者一个函数都需要一个标识符，以便以后再次使用到它。

<p align="center">
  <img src=".\引用图片\017.png" width="300" />
</p>

标识符有两个限制：

1. **标识符**可以由数字和大小写字母以及下划线 _ 组成，但是标识符的第一位不能是数字。
2. **标识符**不能和**关键字**相同。

&nbsp;

> ⚠ 有限的介绍
>
> 这个地方我把真实的语法内容做了很多的简化，而且也省略了一些要素。
>
> 我认为现在我们还无法接触这个内容，之后我会重新多次完善这个语法解析的表述，现在的绘图中都会说明不完整且有改动。

&nbsp;

#### 声明的严谨定义

我们从较为严谨的语法角度上去看，**声明**（declaration）的定义是，向**编译器**解释一个或者多个**标识符**（identifier）的含义以及属性。含义和属性就主要是上述所说的数据类型和内存大小，由**声明说明符**进行限制。

因此我们看一遍声明的完整语法树概念图：

> **概念分类：声明 V1**
>
> <p align="center">
> 	<img src=".\引用图片\018.png" width="500" />
> </p>
> 
> **一些绘图的约定**
> 
>分支没有任何标记，则意味着分支只能选择一次，例如type-specifier下，你可以选择下面的那些中的一个。
> 
>分支如果有圆点标记，则说明这些分支是从上到下依次出现组合而成的，例如declaration是依次由declaration-specifier，一个空格，identifier和一个分号组成的。
> 
>图中的加粗框线（例如declaration-specifier）意味着，子元素可以使用多次。
> 
>剩余的内容则是一些随意的临时注解。
> 
>灰色，按照之前的惯例，是还没有进行讲解，或者仍待改进的一些内容。
> 
>\* 需要注意的是，这个排版非常有限，且内容并不全正确。

&nbsp;

我们在较为正式的文档中，常常会看到一种较为神奇的方法来描述上面这个树结构的语法规则：

> **声明：正式定义V1**
>
> *declaration*：
>
> *declaration-specifiers* *identifier*；
>
> &nbsp;
>
> *declaration-specifiers*：
>
> *type-specifiers* *declaration-specifiers*<sub>OPT</sub>
>
> &nbsp;
>
> *type-specifiers*：
>
> **int**
>
> **short**
>
> **long**
>
> **signed**
>
> **unsigned**
>
> **float**
>
> **double**
>
> \* 需要注意的是，内容并不全正确。

&nbsp;

其中每一个斜体单词都是语法的一个成分，我们之前已经逐一介绍过了他们的中文含义。我们按照定义依次展开语法成分。

&nbsp;

下面这样一个冒号的形式表示定义。下面这个用语言解释就是：*declaration*（声明）是依次由：*declaration-specifiers*（声明说明符），一个空格，*identifier*（标识符）和一个分号的组合组成的。

> *declaration*：
>
> *declaration-specifiers* *identifier*；

&nbsp;

有些时候这种定义会出现包含自己的情况，这样就可以规定出更加复杂的语法结构（即发生了递归的现象）：

> *declaration-specifiers*：
>
> *type-specifiers* *declaration-specifiers*<sub>OPT</sub>

上面这个定义意思是：*declaration-specifiers*（声明说明符）是由若干个有空格分割的*type-specifiers*（类型说明符）组合而成的。角标<sub>OPT</sub>意思是可选，即加或者不加都可以，这样就保证*declaration-specifiers*在展开成*type-specifiers*的时候可以停下来，而不是无限的展开。

&nbsp;

如果遇见了粗体的关键字，则说明遇见了不可展开的关键字，关键字就可以直接出现在程序中了。

> *type-specifiers*：
>
> **int**
>
> **short**
>
> **long**
>
> **signed**
>
> **unsigned**
>
> **float**
>
> **double**

&nbsp;

如果你仔读懂了我之前的声明的语法讲解，再看一看这个内容，你会发现实际上我之前讲了这么多细节，都包含在了上面这几行小小的定义里面，而且也比我绘图更加清晰明了简洁。

&nbsp;

> ⚠ 有限的介绍
>
> 这个地方的正式语法说明不完整且有改动。但是我的改动目的是先隐藏掉一些过于复杂的语法现象，至少在现在能够达到逻辑完整。
>
> &nbsp;
>
> 我知道有些学过编程的知道可以连续声明多个变量，而且变量声明之后可以直接进行赋值
>
> ```c
> int a,b,c,d;
> int a,b=2,c,d=5;
> ```
>
> &nbsp;
>
> 很好，在本文结束的时候我们就会讲解他们，现在请你先忘记他们。
>
> 如果你觉得连续声明和赋值毫无难度，上面这个东西不久看一眼就会了吗？那就请你回答以下的问题：
>
> ```c
> //这个上面和下面这两个等号是完全等同的吗？
> int a=2;
> a=2;
> 
> //这个上面和下面这两个逗号是完全等同的吗？c的值是多少？
> int a,b;
> c=(a=2,b=3)
> 
> //这个声明对不对？如果不对会报什么错？
> int a=b=2;
> 
> //这个声明中后面b是指针还是变量，为什么？
> int *a,b;
> 
> //这两个声明有区别吗？
> int (*p)[10];
> int *p[10];
> 
> //这声明了一个什么？
> char *( *(*var)() )[10];
> ```
>
> &nbsp;
>
> 不是我为难你 ，至少第1,3,4,5个问题是很实用，你平常都可能偶尔在这些问题上犯错。你要回答的起，你可以随便声明，而且你也不用看我这个内容，我之后就会慢慢讲解他们。
>
> 真正需要认识声明，就需要认识语法结构。现在我就在将语法结构拆碎了一点一点给你，尝试着你能够慢慢理解全部内容。你需要理解我的语言讲解，而且还要对上面的正式语法说明有一定的了解和感受。

&nbsp;

&nbsp;

#### 程序运行模型-声明

我们上面吹了这么久，都是语法解析。语法解析再牛逼也是对单语句的解析，我们还需要结合很早之前提及的程序运行模型来观察声明的实际效果，即在观察单行程序在整个程序中产生的效果。

&nbsp;

**声明**的实际操作就是在内存中申请空间，所以遇到声明的时候就在“内存窗口”里面建立一个方卡牌，用于表示这是一个可以存储值的变量。

- 作为一个在main函数中声明的变量，变量的初始值未知。
- 所有的变量都要有一个**标识符**，因此我们在左边标注出他的标识符。
- 不同的**数据类型**对应的内存上面的大小和解析方式是不一样的，因此我们在左上角说明类型。

> ⚙ 程序运行模型构建
>
> **变量卡牌**
>
> 变量卡牌出现在**内存窗口**中。变量卡牌的要素包括：标识符，数据类型类型标识，值。
>
> <p align="center">
> 	<img src=".\引用图片\041.png" width="700" />
> </p>
>
> **声明语句**
>
> 当程序窗口运行到声明语句以后，会在内存窗口中生成一张对应数据类型的，新的，初始值未知的变量卡牌。
>
> <p align="center">
> 	<img src=".\引用图片\043.png" width="700" />
> </p>

&nbsp;

我们来看一眼范例程序，这个程序中只有声明。

<p align="center">
	<img src=".\引用图片\042.gif" width="700" />
</p>
&nbsp;


> ℹ 信息
>
> 如果你研究C语言非常深（这意思是如果你是都不懂的初学者你可以不读下面的内容），你可能直觉上会觉得我这个模型中处理声明并不合理，我也赞同。
>
> C的声明不是语句，因为语句必定需要产生一些效应，而声明实际上并没有产生任何的效应。声明语句并不在程序中得到翻译，没有对应的机器码。程序一行一行执行的时候，并没有说像我这个模型中展示的一样，遇到一个声明就申请一个内存空间。
>
> 这一点和C程序编译原理息息相关。在编译过程中，所有的局部变量的空间被一次性地被申请在了栈区。这也大概是为什么早期C语言非要在块的最上侧声明，而不能把声明往语句下移动。
>
> 不过既然这个内存模型仅仅是为了辅助思考，就不必过于拘泥于实际操作。因此将声明在这个程序运行模型中考虑为一个动态过程也是很有价值的。

&nbsp;

### 📄任务2.1.5-声明的初步语法解析

下面是一些声明的代码，你需要按照题目的提示进行语法解释。同时还有一些问答题。

&nbsp;

## 2.2 表达式语句-初步接触

我们不论再怎么声明，总归就是获得了一些初始值未知的变量。如果不去进一步给变量去赋值，那就等于白干活了。

但是赋值用到**语句**(statement)是C语言中最为复杂的语句——**表达式语句**(expression statement)。如果你还记得到的话，可以看一看如下的语法成分概念图（我已经将声明加入了概念中）

> **概念分类：语法概念 V2**
>
> <p align="center">
> 	<img src=".\引用图片\019.png" width="700" />
> </p>

&nbsp;

上面的**表达式语句**(*expression-statement*)的定义就是末尾带有分号的**表达式**（*expression*），意思是，表达式语句是一种需要分号的语句。我们下面就会开始对**表达式**进行讲解。

&nbsp;

### 表达式的结构

**表达式**(expression)是由**操作数**(operator)和**操作符**(operand，有地方也译作运算符)组成的有序内容。例如说“1+2”（外面的引号不计入语句中），或者说连操作符都没有，直接一个单的操作数“3”也是一种表达式。

**表达式**也可以进行一些复合，例如说”(3+2)\*6“。我们尤其需要关注的是，在表达式复合时，我们要学会对表达式进行子表达式分割，并且学会**表达式求值**。例如说”(3+2)\*6“是复合表达式，子**表达式**“3+2”**求值**为5，于是剩下的表达式就变成”5\*6“，整个**表达式求值**就是30

你可能觉得这个是小学内容了，但是我想用这个案例来进行说明，因为操作数不仅仅可以是一个常数，还有可能是一个标识符，而且我们还需要注意字面值问题（之后会讲解的），因此表达式求值本身并不是说人人都会。

&nbsp;

### 算术操作符

我们目前讲解的**操作数**(operator)都是一些数，因此我们也就相应地接触和数息息相关的**算术操作符**。

```c
3+2;       //加法操作符 "+"，二元操作符，表达式求值后为5
4-1;       //减法操作符 "-"，二元操作符，表达式求值后为3
3*4;       //乘法操作符 "*"，二元操作符，表达式求值后为12
6/2;       //除法操作符 "/"，二元操作符，表达式求值后为3
7%3;       //取余操作符 "%"，二元操作符，表达式求值后为1
-4;        //取负操作符 "-", 一元操作符，表达式求值后为-4
```

需要注意的一个术语，叫做**N元操作符**。定义实际上也很简单，意思就是这个操作符能够接受几个操作数。

如上就有一堆二元操作符和一个一元操作符。因为C中仅仅接受数字作为字面值（后面会解释字面值），所以-4看上去是一个整体，但是还是一个有取负操作符的表达式。

&nbsp;

### 自增/自减操作符

自增和自减操作符是一种**一元操作符**，它的操作数是一个**变量**的**标识符**，它可以让变量增加或者减少。

```c
i++;    // 自增操作符，后置，一元操作符，i的值增加1
i--;    // 自减操作符，后置，一元操作符，i的值减少1
++i;    // 自增操作符，前置，一元操作符，i的值增加1
--i;    // 自减操作符，前置，一元操作符，i的值减少1
```

对于前置还是后置，真的要搞懂他的用法需要精通C，对于单独使用的自增操作符，两者效果是一样的。

&nbsp;

### 赋值操作符

赋值运算符是**二元操作符**，操作符左侧接受一个**变量**的**标识符**，右侧接受一个表达式，赋值操作符可以将等号右侧子**表达式求值**的结果赋予给左侧标识符对应的变量。

下面这一段代码不是案例的罗列，需要依次运行。

```c
int i;
int k;
int m;

i=3;                 //i的值赋值为3
k=i+3;               //k的值赋值为6,是从右侧的表达式i+3进行表达式求值(3+3)得到的。
m=i*k;               //m的值赋值为18,是从右侧的表达式i*k进行表达式求值3*6得到的。
m=(i+k)*m;           //m的值赋值为162,是从右侧的表达式(i+k)*m进行表达式求值(3+6)*18得到的。
```

如上展示了赋值操作符的一些合理的写法。

&nbsp;

### 执行顺序-初步：优先级

也许你早有耳闻，程序中有着m=(i+k)*m;这种第一眼看上去很奇怪的写法，毕竟很多未接触编程的人第一眼会把它看成一个等式。

我们现在已经明白了，这个等号不是数学的等号，是**赋值操作符**。碰到赋值操作符后，我们需要做的是对右侧进行**表达式求值**，得到的结果赋值给右侧**标识符**对应的**变量**。

&nbsp;

不过可能有人会问，为什么我要把右侧的所有表达式全部求值完成才执行赋值，m=(i+k)*m这个表达式不能算完(i+k)就直接赋值给m?

实际上背后的操作符**优先级**机制保障了这一过程的有效进行。在目前我们知道的**操作符**中，优先级从高到低是：

* ++ --              后置自增自减操作符
* \-  ++ --           取负操作符，前置自增自减操作符
* \* / %              乘法/除法/取余操作符
* \+ -                  加法/减法操作符
* =                     赋值操作符

&nbsp;

需要注意的规则有：

1. 越上方的操作符优先级更高，更加早进行表达式求值。

2. 括号会改变表达式求值的顺序。
3. 如果同时遇见同等级的操作符，则按照结合性顺序的规律进行依次求值。大多数的操作符都和我们习惯一致，具有从左到右的结合性。但是**取负操作符**和**赋值操作符**结合顺序是从右到左。

&nbsp;

一个非常全的[C优先级总表](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence)可以在维基百科上找到，但是现在不太推荐阅读，因为其中的大多数操作符你都认不到。

&nbsp;

### 表达式求值和副效应

你是否隐约感受到，虽然同为操作符，但是加减等**算术操作符**和**赋值操作符**有一点本质性的区别，只不过又不太能够描述究竟是什么？没有错，我们将引入两个针对表达式的术语，**表达式求值**(evaluate)和**副效应**(side effect)。

**表达式求值**的含义我们已经了解了，就是**表达式语句**按照优先级进行求值，使得每一个子表达式都有一个对应的值。我们常常也称（子）表达式返回值来描述表达式求值结果。

**副效应**则是一个**语句**在表达式求值以外产生的效应，例如内存或者文件的读写，或者对屏幕的输出，对键盘的读入。

&nbsp;

因此，对于**赋值操作符**，其**副效应**是将等号右侧的子表达式求值的结论写入左侧标识符对应的变量中的内存里；其**表达式求值**的结果就是右侧的子表达式求值的结果。

<p align="center">
	<img src=".\引用图片\044.gif" width="800" />
</p>

这听上去可能有点可笑，毕竟赋值操作应该才是我们“主要”想要使用的功能。不过这个分类是想从表达式语法的角度来区分不同的效应。

&nbsp;

因为赋值操作符的这个特性，再加上赋值操作符的右到左的结合性，我们才能合理使用连续的赋值操作符。

```c
int a;
int b;
int c;
a=b=c=2;
```

<p align="center">
	<img src=".\引用图片\045.gif" width="800" />
</p>
&nbsp;


### 复合赋值操作符

在最后，作为“附赠”，介绍一组可以“偷懒”的复合赋值操作符，他们都是**二元操作符**。

```c
i+=2;      //复合加法操作符 "+="，二元操作符，等价于i=i+2;
k-=3;      //复合减法操作符 "-="，二元操作符，等价于k=k-3;
i*=k;      //复合乘法操作符 "*="，二元操作符，等价于i=i*k;
m/=2;      //复合除法操作符 "/="，二元操作符，等价于m=m/2;
i%=2;      //复合取余操作符 "+="，二元操作符，等价于i=i%2;
```

复合赋值操作符的**优先级**等同于赋值操作符，结合顺序也是遵照赋值操作符，从右到左。

&nbsp;

&nbsp;

### 📄任务2.2-表达式语句的初步语法解析

下面是一些表达式的代码，你需要按照题目的提示进行语法解释。同时还有一些问答题。

&nbsp;

## 2.3 如何输入输出

我们操作了一堆东西，但是很遗憾的是，我们完全没有办法将内容打到屏幕上，他们都在内存中进行了一些运算然后就在程序结束以后立马消失了！

所以，我们需要用一些方法将内存中的变量数据打印到屏幕上。掌握了下面这个内容，再结合你之前的认识，你大概就已经会最为基础的编程了。

&nbsp;

### 函数-初步接触

首先，我们在正式谈及输入输入之前，不得不谈一谈**函数**。

&nbsp;

你可以将函数看作一个“自定义模块”。如果你想要进行一些较为复杂的，涉及多个初始值和一个结论的运算，那么你可以**定义**一个函数。定义一个函数和写main函数的格式几乎一致。例如我们定义一个很鸡肋的，将两个整数进行相加的函数。

```c
int adder(int a,int b){
    return a+b;
}
```

我们从参数列表中看到，这个**标识符**为adder的函数接受两个int型的变量，这两个变量在函数内部拥有标识符a和b，**函数返回值**是表达式a+b的结果。

&nbsp;

如果将函数的定义和main函数放在一起，那么我们可以有如下的例子：

```c
int adder(int a,int b){
    return a+b;
}
int main(void){
    int num1;
    int num2;
    num1=3;
    num2=6;
    
    int sum;
    sum=adder(num1,num2);   //调用函数
    
    return 0;
}
```

adder函数需要写在main函数前面，因为C语言要求调用前至少必须要有定义。这并不影响程序的流程，因为我们已经在第一章讲过了，程序是从main函数的大括号中第一行开始执行的，上面的adder函数对程序从哪里开始并无影响。

在“调用函数”行，我们用如上的形式**调用**了adder**函数**，需要注意的是，调用函数本身也是一个**表达式**。**操作符**是括号，**操作数**是括号左侧的函数标识符，以及括号内的作为参数的变量。他的**表达式求值**由函数**定义**中的return语句后的表达式决定，**副效应**也由函数自己定义，这里没有副效应。

main函数中的num1和num2被送入到了adder函数中的参数a和b中。然后程序的执行流程就进入了adder函数。整个adder(num1,num2)**表达式求值**的结论，是执行了adder函数中return语句后面的表达式求值，即a+b，也就是num1+num2，也就是9。sum最终被赋值9；

<p align="center">
	<img src=".\引用图片\049.gif" width="800" />
</p>

&nbsp;


> ⚠ 有限的介绍
>
> 这里有太多的东西没有讲解了，例如说函数的**定义**和函数的**声明**之间的关系，还有**作用域**的含义，以及函数的正式语法规定。而且我也欠大家关于void关键字的介绍。但是这个地方受本章节篇幅和读者知识储备的影响，我最终决定将这些内容向后挪动。
>
> 不论如何，上面的文字还是能够大概支撑现在的理解，而且你也可以依葫芦画瓢，写出一个自己的函数。

&nbsp;

### 库函数

大概知道函数是个啥以后，我们就要谈及C语言的一个利器，那就是**库函数**。

表达式基本上可以说是C语言最最强大的功能了，但是对于编程者来说，C语言提供的操作符是完完全全不够的。再怎么整，C语言就是一个功能强一点的计算器而已。而我们刚才又知道了，函数就像是一个“自定义模块”一样，**main函数**里面一句**调用函数**，就可以让已经定义好了的函数开始执行。

那么就有人动了脑筋，如果我们把程序员常常用到但是不属于C语言核心功能的东西，全部都编写成一个个函数，这些函数按照功能分类打包，然后我们让程序员们按需取用，岂不妙哉？

&nbsp;

没有错，这些按需打包供人取用的函数集合，就是C的**库函数**，这是C语言的一大原创发明。当你的程序需要使用**库函数**的时候，你可以将类似下面这一句代码加入到程序的最开头（main函数外面，最前面）

```c
#include<stdio.h>
```

这样你就在你的程序中，包含了一个名字叫stdio.h的**库函数**（我们也称引入了stdio.h）。然后你可以按照参考资料，在自己的程序中使用stdio.h里已经编写打包好了的各种函数。

&nbsp;

至于有哪些库函数，以及库函数里面究竟有些什么函数可以用，我们可以在国内一个优秀的学习站[菜鸟编程](https://www.runoob.com/cprogramming/c-standard-library.html)中查到参考(左侧目录往下滑动就是库函数的参考内容)。

当然得说，这个参考太简易了，只适合已经知道内容只不过在忘了的时候想要查一查的情况。所以我会在下面讲解**库函数**中涉及到输入输出的**函数**。

&nbsp;

### 输入输出函数-初步接触

输入输出函数都是在stdio.h中定义的，所以在使用之前一定记住要引入stdio.h。

&nbsp;

#### 输出函数 printf()

输出函数名字叫做printf，其中的f是"formatted"的简称，即”格式化的“。这个函数本身的用法很多，不过我们现在就用它最简单的几种用法。

首先需要知道的前提是，printf语句会在黑色的控制台窗口中指挥光标的动作进行输出。在程序开始的时候，光标会在程序的最左上角：

<img src=".\引用图片\029.png" style="float:left;" width="800" />

&nbsp;

##### 打印常值字符串

1. 基础使用：printf接受的第一个参数一定是字符串。这个参数中的内容会直接显示出来。例如下面这个程序的输出

   ```c
   #include<stdio.h>
   int main(void){
       printf("Hello World!");
       return 0;
   }
   ```

   <img src=".\引用图片\030.png" style="float:left;" width="500" />

   我这里使用了一些技巧使得屏幕在程序退出之前暂停了下来，因此才能截图（否则窗口就消失了）。需要注意的是，光标停在了"Hello World!"的感叹号后面。

   &nbsp;

2. 多次使用：printf多次使用，就是多次指挥光标进行移动，依次执行。

   ```C
   #include<stdio.h>
   int main(void){
       printf("Hello World!");
       printf("也可以打中文");
       printf("This is another line.");
       return 0;
   }
   ```

   <img src=".\引用图片\031.png" style="float:left;" width="550" />

   需要注意的是，格式化输出的时候是连续无间隙指挥光标进行输出的，因此像上面这个代码，三句中间每没有任何空格的。如果想要空格，需要自己加入到字符串里面。

   &nbsp;

3. 有一些非打印字符，例如说回车，你没有办法在代码中进行展示。

   ```c
   #include<stdio.h>
   int main(void){
       printf("这样是
               不行的，会被认为是错误");
       return 0;
   }
   ```

   因此需要引入一些字符，叫做**转义字符**（也有人叫做逃逸字符）。在**字面值**为**字符**或者**字符串**的内容中（即单引号和双引号中），可以采用反斜杠\作为开头来表达一些字符。

   | 转义字符     | 转义字符输出内容                                             |
   | ------------ | ------------------------------------------------------------ |
   | \a           | 响铃，现在主板上一般没有蜂鸣器了，所以用的一般是系统内部提示音 |
   | \n           | 换行，即光标到下一行                                         |
   | \r           | 回车，即光标回到本行的开头（与我们平常认为的回车不同）       |
   | \b           | 退格，光标后退一格（不删除内容，除非你再输入覆盖内容）       |
   | \t           | 光标向右进入下一制表位，一般制表位是第1,9,17,25个字符的位置  |
   | \\"          | 输出双引号                                                   |
   | \\'          | 输出单引号                                                   |
   | \\\\         | 输出斜杠                                                     |
   | \\<u>ooo</u> | <u>o</u>表示一个八进制数字，输出对应ascii表内容，例如\171是指ascii表97位即‘a’，可以省略前面的零，例如\033可以写做\33，仍然会被理解为八进制。 |
   | \x<u>hh</u>  | <u>h</u>表示一个十六进制数字，输出对应ascii表内容，例如\x61是指ascii表97位即‘a’ |

   &nbsp;

   如下是一些使用案例：

   ```c
   #include<stdio.h>
   int main(void){
       printf("这是独立的一行。\n");
       printf("新的一行。\nAnd this is a new line.\n");
       printf("hypergraphUniverse:\"你看懂了吗？\"");
       return 0;
   }
   ```

   <img src=".\引用图片\032.png" style="float:left;" width="550" />

   当然转义字符有一些比较有意思的用法，而且除了转义字符，我们还可以有一种更加强大的方法来控制显示，不过现在基本会控制输出就好了。

&nbsp;

##### 打印变量

4. 之前的使用都是输出常量，现在我们希望能够把程序里面的变量也拿出来输出。这一点是很可以的，只不过我们还要引入一个新的东西，叫做**转换说明**。

   我们知道内存中不同的数据类型的编码方式不一样，而转换说明就是去告诉函数，用什么样的方式去解读并且显示这个地方的内容。

   常见的转换说明如下表格：

| 转换说明 | 解释                                              |
| -------- | ------------------------------------------------- |
| %d       | 十进制有符号整数，适用于int                       |
| %f       | 浮点数                                            |
| %c       | 字符                                              |
| %u       | 十进制无符号整数，适用于unsigned int              |
| %%       | 由于%有语法功能了，所以真的要打印百分号需要打两次 |

&nbsp;

​	**转换说明**出现以后，需要和printf第一个参数以后的参数去表示，究竟是哪个变量来填补这个转换说明。

​	后面的参数不一定非要是一个变量的名字，可以是一个**表达式**，例子：

```c
#include<stdio.h>
int main(void){
    int note=95;
    char grade='A';
    float percent=0.0136;
    printf("您的分数:%d\n",note);
    printf("您的评级:%c\n",grade);
    printf("您在年级上处于前百分之:%f%%\n",percent*100);
    return 0;
}
```

<img src=".\引用图片\033.png" style="float:left;" width="600" />

&nbsp;

也可以多个转换说明放在一起，一一对应即可。

```C
#include<stdio.h>
int main(void){
    int note=95;
    char grade='A';
    float percent=0.0136;
	printf("您的分数:%d\n您的评级:%c\n您在年级上处于前百分之:%f%%\n",note，grade,percent*100);
    return 0;
}
```

​	**转换说明**里面有一条是字符串，而且很常用，但是因为指针的概念没有被引入，所以我暂时不讲。

&nbsp;

5. 对于**浮点数**而言，我们再引入一个东西叫做**转换说明限制符**。

   你是否觉得刚才那个程序的输出中，浮点数是否有点太难看了，为什么那么多个没用的零？所以printf提供了输出有限个小数位数的方法：将%f改写成%.2f，于是小数点后只显示两位了。

```c
#include<stdio.h>
int main(void){
    float percent=0.0136; 
    printf("您在年级上处于前百分之:%.2f%%\n",percent*100);
    return 0;
}
```

<img src=".\引用图片\034.png" style="float:left;" width="500" />

&nbsp;

#### 输入函数 scanf()

使用输入函数的时候，我们不得不引入一个我们目前还不是太熟悉的内容，一个现在暂时还很陌生的操作符，”&“**地址操作符**。

&nbsp;

相比起输出，输入的第一个参数没有那么多花里胡哨（目前而言），双引号中只有一个**转换说明**，转换说明如下：

| 转换说明 | 解释                                 |
| -------- | ------------------------------------ |
| %d       | 十进制有符号整数，适用于int          |
| %f       | 单精度浮点数，适用于float            |
| %lf      | 双精度浮点数，适用于double           |
| %c       | 字符(现在请拒绝使用这个内容！)       |
| %u       | 十进制无符号整数，适用于unsigned int |

例如：

```C
#include<stdio.h>
int main(void){
    int num;
    scanf("%d",&num); 
}
```

当程序执行到scanf函数的时候，会停下来，光标闪烁等待用户输入一个十进制数。在用户输入之后按下回车表示结束以后，输入的内容就会被放到num变量里面。（请不要去思考如果你输入包含非数字的情况，这种情况背后经历的过程太多，现在无法给你分析）

&nbsp;

为什么转换说明对应的参数会是&num，而不是num呢？我们可以靠我们目前的理解做出一个解释。

<img src=".\引用图片\046.png" style="float:left;" width="800" />

后面的这些参数都是一个**表达式**，表达式求值结果进入scanf函数进行处理，而处理过程中，输入输出到屏幕是其**副效应**。

作为输入，scanf函数实际上做的是，将某一个来自键盘的值写入到这个变量在**内存**中对应的位置——这才算是改变了这个变量。因此我需要的是这个**变量**在**内存**上的**地址**，计算机才能够在内存中找到他的位置进行改写。而这个过程我需要的就是带上**地址运算符**，表示num变量所在地址的表达式&num，而不是变量的值。

&nbsp;

我们再看一个案例。

由于你已经在现在掌握了编写程序所需要的最基本内容了，所以下面这个程序就有一点点交互能力了：

```C
#include<stdio.h>
int main(void){
	int num;
	printf("请输入你想运算的数字:"); 
	scanf("%d",&num); 
	
	printf("%d的平方是%d\n",num,num*num);
	printf("%d的立方是%d\n",num,num*num*num);
	return 0; 
}
```

&nbsp;

运行的范例如图：

<img src=".\引用图片\035.gif" style="float:left;" width="600" />

&nbsp;

> ⚠ 有限的介绍
>
> 我又知道学习过C语言的人觉得我又藏着掖着没有讲完了
>
> 首先是转换说明有一些没有讲解。但是如果要详尽地讲解，可能组合起来有三四十个，你根本无法分辨出他们的关系和差别。
>
> &nbsp;
>
> 我还要告诉你的是，这两个函数背后的概念和特性也是惊人的多，之后我甚至会用一个专题来讲解背后的概念。
>
> 因此，现在我要求你每一次就输入严格按照我的要求来操作。输出的话可以稍微宽松一点，能够将变量和文字一起混用。只要按照我目前的要求来做，你就不会出现理解之外的问题。

&nbsp;

### 程序运行模型-输入输出

程序的输入和输出实际上是和外界的交互，和程序本身没有关系，因此我们规定在内存界面右侧有输入输出的”接口“，来代表这个”来自外界“的数值。

&nbsp;

> ⚙ 程序运行模型构建
>
> **输出输出接口**
>
> 这个地方就是输入内容的源头，以及输出值的去向。对侧分别对应用户的键盘和屏幕，由操作系统统一管理。
>
> <img src=".\引用图片\048.png" style="float:left;" width="200" />
>
> **scanf和printf语句**
>
> 这两个语句则建立了和接口的关系。能够达到改变内存值和输出到屏幕的效果。

&nbsp;

我们来看一眼范例程序。

<p align="center">
	<img src=".\引用图片\047.gif" width="800" />
</p>
&nbsp;


### 📄任务2.3.1-输入输出问答

下面是一些关于输入输出的问题。

&nbsp;

### 📄任务2.3.2-输出你计算机的变量字节数

C有一个关键字sizeof，你可以像函数一样使用它，后面的括号中需要放入一个**声明说明符**，例如sizeof(int)。这样一个长得象**表达式**的东西**求值**之后，得到的是这个数据类型在你的计算机中占有的字节数。

现在请补全2.3.2中的代码，使得屏幕输出如下：

```
The int in this computer has 4 Byte(s);
The short in this computer has ...
...
```

补全代码后，观察你计算机中int, short, long, long long, char, float, double所占的字节数。保存编写编译完成的代码，并且复制一份在你的电脑屏幕上的结论到同目录的txt里面。

&nbsp;

## 2.4 声明/表达式-初步接触(2)

我们认识了如上的一系列内容之后，算是对声明和表达式有着初步理解了，实际上你已经可以开始编写小程序了。但是别跑太快！第一次正式编程之前，我还有一些话题想要探讨，用来帮你避免一些错误。

&nbsp;

### 声明的初步语法解析(2)

我之前没有讲解一个事情，那就是在声明的时候你可以赋一个初始值。之所以现在讲，是因为你现在对**表达式**是什么已经有了初步理解了，我就可以在关于声明的语法树中添加更多的内容了——也就是之前提及的，同时声明多个变量以及初始赋值的问题。

声明前面一部分，*declaration-specifiers*，我暂时还不需要进行修正。主要是后半段，需要容纳更多的内容。

&nbsp;

#### 声明后半段：*init-declarator-list*

<p align="center">
  <img src=".\引用图片\036.png" width="400" />
</p>

声明的后半段这样大一部分，被称作**初始声明符列表** *init-declarator-list*。

&nbsp;

<p align="center">
  <img src=".\引用图片\037.png" width="500" />
</p>

**初始声明符列表** *init-declarator-list* 由多个**初始声明符** *init-declarator* 用逗号分割而成

&nbsp;

<p align="center">
  <img src=".\引用图片\038.png" width="500" />
</p>

**初始声明符** *init-declarator* 有两种形式，一个就是光杆的**声明符** *declarator*，另外一个则是 **声明符=表达式** *declarator=expression*的组合内容。这个地方的*expression*就是我们之前学过的**表达式**。

&nbsp;

<p align="center">
  <img src=".\引用图片\039.png" width="300" />
</p>

而目前我们所知的**声明符** *declarator*就是**标识符**，也就是我们一开始认为的后面的部分。

&nbsp;

语法树如下：

> **概念分类：声明 V2**
>
> <p align="center">
> 	<img src=".\引用图片\040.png" width="450" />
> </p>
>
> \*内容仍然有待填充和修正。

&nbsp;

正式定义如下：

> **声明：正式定义V2**
>
> *declaration*：
>
> *declaration-specifiers* *init-declarator-list*；
>
> &nbsp;
>
> *declaration-specifiers*：
>
> *type-specifiers* *declaration-specifiers*<sub>OPT</sub>
>
> &nbsp;
>
> *type-specifiers*：
>
> **int**
>
> **short**
>
> **long**
>
> **signed**
>
> **unsigned**
>
> **float**
>
> **double**
>
> &nbsp;
>
> *init-declarator-list*:
>
> *init-declarator*
>
> *init-declarator-list*, *init-declarator*
>
> &nbsp;
>
> *init-declarator*:
>
> *declarator*
>
> *declarator=expression*
>
> &nbsp;
>
> *declarator*:
>
> *identifier*
>
> &nbsp;
>
> \* 需要注意的是，内容并不全正确。

&nbsp;

出现了两行的情况，则意味着两个定义选择一个使用。如下这个定义总体解读出来，意味着*init-declarator-list*由多个用逗号分开的*init-declarator*组成。

> *init-declarator-list*:
>
> *init-declarator*
>
> *init-declarator-list*, *init-declarator*

&nbsp;

### 类型转换和字面值

这个内容在刚才的讲解中好多次都呼之欲出了，但是每一次我都尽量避免了它。我希望你已经理解了很多语法知识之后再来理解他们。

&nbsp;

C语言从程序中的任意一个常量开始，就有它自己的**数据类型**。

需要注意，常量是操作数的一种，也就是说常量是最小的**表达式**之一，而表达式是能够**求值**的。

而我想在这里告诉你的是，**表达式求值**的过程中，表达式的**数据类型**和**数值大小**同等重要，都是表达式求值中的一个关键要素，会被一直向更大的表达式中传递。

这种**常量**具有的数据类型就叫做**字面值**。字面值究竟是什么，和常量的书写方式有关。

```c
1213         //如果你直接书写纯数字，字面值是int
    
1213U        //如果你书写纯数字后加上后缀U,L或者他们的组合，字面值是应组合而成的unsigned/long类型;
1213L
1213l        //大小写都可以，但是我推荐大写，因为l和1以及I容易搞混
1213LL
1213ULL
1213ULL

0x7FFF       //使用0x前缀，可以在后面书写十六进制形式的数字，字面值仍然是int
0X7FFF       //大小写，x还是X都可以
    
1213.        //出现了小数点的数字（即使小数位或者整数位是残缺的），字面值是double
.41
2.21
2E3          //计算机中的科学计数法常量是如此写出来的，2E3表示2乘10的3次方，字面值是double
1.3e-1       //大小写都可以，即使最后的结果是整数，这种书写方法决定了字面值
    
'a'          //用单引号括起来的字符，是字符类型的常量，字面值是char
'c'          //如果不括起来大概率会被认为是标识符

"Hello World!" //用双引号括起来的一系列字符，是字符串类型的常量，我们还没有学指针，因此不去深究
```

&nbsp;

在表达式过程中，存在自动**类型转换**的情况。

**数据类型**之间有一个等级关系（关系过于复杂，不列总表了。依靠你自己对于数据类型的理解你可以分辨升级或者降级的）

从容纳范围小到容纳范围大的类型转换叫做**类型升级**，类型升级基本没有什么问题。

```c
7/3.1         //7字面值是int,3.1字面值是double,因此类型就升级成了double了
//(需要注意的是7/3因为两个操作数都是int，因此字面值维持为int不变，求值结果为2)
'a'+999       //'a'字面值是char，ascii表中对应数是97，但是97+999就超过了char类型上限，因此升级为int
2147483647+1  //2147483647是int能够容纳的最大值，+1之后自动升级为long或long long
```

&nbsp;

从容纳范围大到容纳范围小的类型转换叫做**类型降级**，编程中不要主动引入类型降级，因为这一定会引起数据的丢失，如果类型降级会被某些编译器的警告（不包括Dev-C++）。

```c
int a;
a=3.14;            //3.14是小数，但是送到了int里面，尾数会被截断

float b;
b=3.1415926535;   //float的精度在7位小数，这个小数精度无法被float容纳（顺便算一算double是几位）
```

&nbsp;

实际上常量的类型转换不算什么大问题（当然丢失数据本身是一个问题），和指针类型错误相比，这种失误不会被编译器给拦下来。

但是这种“侥幸”并没有必要出现在你的程序中。在声明某个变量的时候，就考虑好究竟用谁比较合适，不会出现丢失信息的问题。

&nbsp;

偶尔你会遇到类型转换会遇到警告，或者说你就是想要强制转换类型。在这个情况下，你可以使用一个**二元操作符**来完成类型转换，叫做类型转换操作符"()"。语法用法如下：

(*type*)*expression*

括号中接受想要强制转换的**类型**（并不完全等价于声明说明符，因为完整定义中声明说明符中，不止有类型说明符，这个括号中只接受类型说明符），括号右侧是待转换的**表达式**。这个操作符的优先级和前置自增自减操作符一致。（可以查阅[总表](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence)）

下面是一些例子：

```c
int a;
a=3.3/1.8;                 // 3.3/1.8约等于1.83，赋值给a的时候经历类型降级，截断尾数，a是1
a=(int)3.3/(int)1.8;       // 首先经历强制转换后表达式求值为3/1，a最终是3
```

&nbsp;

另外，涉及到char**类型**的**转换**，总是会让一些新手有些不知所措。

这里的案例，可以让各位仔细思考一下（请你打开一份你看得懂的ASCII表对照查阅）：

&nbsp;

本质上思考，char类型变量可以当作一个只能够存储很小的数的整型变量。主要取决于我们怎么解读他。

这意味着，我们将整数类型的变量赋值给char是完全没有问题的。只不过我们需要参考ASCII表中来获得我们想要的内容：

```c
#include<stdio.h>
int main(void){
    char a,b,c;

    a='A';
    b=65;        //在ASCII表中'A'对应的65，所以上述过程是完全等价的，只是用到了不同字面值

    a='C';
    b='A'+2;
    c=67;        //在ASCII表中字母是连贯的，因此'A'+2就是'C'，上述三种使用都是等价的
    
    printf("%c",a);  //显示:C
    printf("%d",a);  //显示:67
 //实际上在输出的时候，也取决于你怎么解读。你把他解读成字符就是字符，解释成数就是对应的ASCII码
}
```

&nbsp;

### 📄任务2.4-声明和表达式(2)问答

下面是一些关于上述章节的问题。

&nbsp;

## 2.5 一些编程前的准备

还有一些东西！这些东西不是特别关键，至少它不是必做的内容，但是作为编程的小技巧，我仍然需要提及他们。

&nbsp;

### 注释

C语言有两种注释方式，注释可以出现在程序中任意语句之间，会被编译器之间忽略。

&nbsp;

第一种注释方法是双斜线，双斜线右侧就是注释内容，都会被编译器忽略。

```c
int a;          //声明一个int类型的变量a
```

&nbsp;

第二种注释方法是一对这个符号/* */，夹在中间的内容会被认为是注释。

```c
/*这是我写的程序
  这里全都是注释
  随便写什么都无所谓*/
int a;
```

&nbsp;

第二种注释方法需要小心，如果出现嵌套则会引发大问题

```c
/*这里是注释
  /*这里嵌套的注释中，前一半符号被认为是注释
    嵌套注释
    很遗憾的是，嵌套注释的后一半符号会被认为是第一个注释符号的结束
  */
  所以，这一段就会被编译器放到正文里面*/
```

&nbsp;

### 关注高亮颜色

很多时候，作为一个合格的IDE，其中一个重要的内容就是将颜色高亮出来。这一点对于编程非常重要，下面是一个程序，你会发现高亮器会为你：

1. 将所有的**关键字**都加粗
2. 数字，字符，字符串等字面值常量都有自己特有的颜色，注释和与预编译指令也有自己的颜色
3. 很多符号，例如分号，括号会标成特有的颜色

<img src=".\引用图片\026.png" style="float:left;" width="350" />

&nbsp;

4. 点击括号/大括号的时候，会为你高亮出另外一半。

<img src=".\引用图片\027.png" style="float:left;" width="300" />

&nbsp;

关注高亮颜色会为你在复杂的表达式中找到问题。

例如说刚才提及的嵌套注释，你会观察到有一部分注释不是蓝色的。

<img src=".\引用图片\022.png" style="float:left;" width="400" />

&nbsp;

例如说你一不小心打了一个中文分号，你会发现这个地方分号不是红色的。

<img src=".\引用图片\023.png" style="float:left;" width="150" />

&nbsp;

这种经验会帮你很快定位到问题。

&nbsp;

### 你的输入法

请不要使用中文输入法来打字！虽然Dev-C++会标注出错误的中文括号和分号，但是中文空格就不一定了。

（当然，现在的微软输入法已经很难打出全角字符了，而且也很难进入全角输入的模式了，所以相比起以前来说，这个问题不太可能发生了，但是防止你某一天一不小心按到了一组稀有的快捷键导致输入法发生了变化这种事情发生，还是请使用英文(美国)输入法比较好）

&nbsp;

我倒是可以凭着多年的直觉，一眼看出来这里有一个是中文空格，一个是英文空格，但是这个问题也是很不必要的。

<img src=".\引用图片\020.png" style="float:left;" width="150" />

&nbsp;

那这个呢？我也看不出来！（第二行分号后面有一个中文全角空格）

<img src=".\引用图片\021.png" style="float:left;" width="150" />

&nbsp;

然后你就会被编译器疯狂报错骚扰，但是你看了代码觉得自己毫无问题，只有崩溃的份。

&nbsp;

### 错误和警告

如果你按下了编译运行，但是Dev-C++没有弹出黑窗口，而是在下面给你了一些内容，红色或者黄色，这说明你犯了一些问题。这就是折磨编程人员的东西了：错误和警告。

C语言编程中，你不应该留下任何一个问题，包括警告。遇到的时候首先需要看见**行号**，定位到对应的位置上（Dev-C++也会帮你定位到第一个行号的），进行排查。自己搜索一下是什么意思，或者问我也成。

<img src=".\引用图片\028.png" style="float:left;" width="600" />

&nbsp;

### 一个建议：采用更加严格的警告

建议使用c99或者以后的标准，获取一些新的特性。

```
-std=c99
```

如果你想要培养更好的代码习惯（即更加严格的语法习惯，但是有些题我会提示关掉这些警告）。

```
-Wall -Wextra
```

&nbsp;

请你打开你的编译器”编译选项“中添加如下的参数。

<img src=".\引用图片\024.png" style="float:left;" width="400" />

<img src=".\引用图片\025.png" style="float:left;" width="400" />

你需要注意的是如果选择了后面的选项，你会遇见更多的警告。出现警告之后，尝试着修复他们。

&nbsp;

### 📄任务2.5-基础编程任务1

Finally！这是你第一次收到正儿八经的编程任务。因为你只会C的表达式语句，能做的事情仍然很有限，所以这一次的编程内容比较单调简单，之后会更加丰富的。除开了这里，编程任务程序里面也会有一些合适的提示。

&nbsp;

#### 2.5.1-录入用户数据

现在你需要制作一个（非常简陋的）录入用户数据的信息收集器。

分别向用户要求输入：生日年/月/日，电话号码。

输入流程如下，非加黑内容是程序显示，加黑内容是用户输入范例，\<Enter\>指的是用户按下了回车。

> Your Birthday<br>
> Year:**2000\<Enter\>**<br>
> Month:**1\<Enter\>**<br>
> Day:**1\<Enter\>**<br>
> Your telephone:**13000000000\<Enter\>**

（不要求校验任何数据的正确性）

&nbsp;

最后一个按钮按下去后，程序紧接着输出用户的信息：

> \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
>
> Info:
>
> DOB:2000/1/1
>
> Tel:13000000000
>
> \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

&nbsp;

提示：

1. 对于long long 类型的变量转换说明是"%lld"

2. 必须在编译器选项中打开"-std=c99"，并且暂时关掉警告"-Wall -Wextra"(看下面的"一个建议"中的操作)；
3. 这个程序用自动化检测脚本会显示上有一些差异，请自主手动检查或者有问题的时候询问我。

&nbsp;

#### 2.5.2-摄氏度与华氏度

现在你需要制作一个（非常简陋的）运算摄氏度转换为华氏度的工具。

公式：华氏度=摄氏度*1.8+32

输入可以是任意的小数或者整数，要求输出的时候华氏度一位小数精度。

输入流程如下：

> **24.213\<Enter\>**

&nbsp;

程序输出信息：

> --The Celsius to Fahrenheit tool--
>
> 24.2°C is 75.6°F

&nbsp;

&nbsp;

#### 2.5.3-圆的计算器

现在你需要制作一个（非常简陋的）运算圆的各项参数的工具。

圆周率取3.1415，公式不会自己查。

输入一个半径，返回：直径，圆的周长，圆的面积，球体的表面积，球体的体积。输出两位有效小数精度。

输入流程如下：

> **4\<Enter\>**

&nbsp;

程序输出信息：

> 圆相关的计算结果：<br>
> 半径：4.00[m]<br>
> 直径：8.00[m]<br>
> 周长：25.13[m]<br>
> 面积：50.26[m^2]<br>
> 表面积：201.06[m^2]<br>
> 体积：268.07[m^3]

(尤其小心，这个冒号是中文符号！)

&nbsp;

### 测试你的程序

你需要按照题目中给出来的一些提示来进行程序的测试，如果所有的数据都符合要求，则程序过关。

如果你在文件夹中发现了一个bat文件，则意味着这个bat文件可以用于校验你的程序。如果说出现了问题，就会输出我的范例程序和你的程序之间的差异。你是不是有一种感觉，原来bat脚本还可以这么强啊。

&nbsp;

但是这个方法用的是系统的原生对比，功能不足，就有几个问题：

1，对于交互式的输入，（你有多次的询问，进行多次问答之类的），用bat进行自动化对比会和手动输入有一些差异，结论有一些不太好看。如果你之后仔细学习过了printf和scanf，你会意识到为什么。

2，没有办法高亮出一些问题，例如文字后的空格。

我也在尝试更加智能的判断自动化，但是目前Windows系统下，这个东西不太可能简单方便实现（Linux系统脚本的话就可以一个原生的Expect+Send就好了）。而且这周写文章又字数炸裂，逼近2w字，已经变成周末两天日更万字还要自己配图的机器人，然后再花一天时间查资料做这个自动校验程序（主要过程是看各种资料找可能方法，无果而终，写了个bat脚本），再花一天做动画😂。

所以这个更加智能的测试程序就暂时拖延着了。

&nbsp;

------

本次采纳了一些参考资料：

1. Microsoft C language documentation : https://docs.microsoft.com/en-us/cpp/c-language/?view=vs-2019
2. Wikipedia Operators in C and C++ : https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence

------

作者 - Author: Thomas Yao

GitHub名 - GitHub username: [hypergraphUniverse](https://github.com/hypergraphUniverse)

联系作者邮箱 - Email：hypergraphUniverse@outlook.com

![](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png)

除非另有说明或授权，本文档中的内容，包括但不限于文字以及原创图片按照[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)协议发布。请在遵守协议的情况下使用本文档，请注意下方对某些情况的法律提醒，**尤其**是在各类**自媒体平台上转发**的说明。请适当且明显地标注出处。

This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy of this license, visit [http://creativecommons.org/licenses/by-nc-sa/4.0/](http://creativecommons.org/licenses/by-nc-sa/4.0/) or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA. Please indicate the source clearly and appropriately when using. 

&nbsp;

法律提醒：

CC协议对于作品的转载与使用的约束相较于传统版权较为宽松，但是您仍然需要在使用的时候严格遵守协议，充分尊重版权。下面的文字，提供了详细的解释，希望您能够阅读后注意。如果如下文本的解释与原[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)协议有出入，请以原协议解释为准。

&nbsp;

本协议允许您对于本作品进行使用以及改编，但是您需要在使用、改编、再发布的过程中遵守以下的要求：

1. **保留著名权**。您使用本作品的行为必须给出适当的**原作者署名**，以及提供指向**本许可协议的链接**，同时**标明是否**对原始作品作了**修改**。

   适当的著名包括但不限于原作者的名字，以及指向原作品的链接等。这里建议您在转载过程中，至少要加入如上的两个原作者信息。且请您务必在显著的位置上进行原作者著名。

2. **非商用**。您不得将本作品以及基于本作品的改编内容用于商用目的。

   需要注意的是，商用目的**并非仅仅意味着获得金钱**的收入，在转发到自媒体平台上时尤其需要注意，详情参见后面的注意事项。

3. **遵守同协议**。如果您再混合、转换或者基于本作品进行创作，您必须**基于与原先许可协议相同的许可协议**分发您贡献的作品。

   您可以在Common Creative官网上找到和CC BY-NC-SA 4.0相兼容的协议。

&nbsp;

您需要注意的一些事情：

1. 非商用（NC）的限制并非仅意味着直接的金钱收入，商用的含义包括了直接或者非直接获得利益。

   很明显，在没有原作者的授权下，您**不能**将作为**收费文章**转发，否则违反了本协议；如果您将本文章以免费文章的形式转发于某种形式的自媒体，其获得的**观众打赏，流量分成或者广告分成**仍然属于一种商业利益，其也是违反非商业限制的；即使您关闭掉了所有的收益功能，未从中获得任何直接的金钱利益，您仍然有利用本文章**提高您知名度**的嫌疑，其也会被视作一种商业利益。即使最终本作品未给您带来任何实际的流量，您实际上已违反了本协议。

   上述的案例尤其适用于微信、微博或者其他社交传媒平台上，以盈利或引流为目的而创立、运营的帐号。

   如果您将本作品进行**改编**，例如制作成视频，将其发布在任一平台上，您仍然面对如上相同的情况。且改编人不得不面对SA条款带来的更多约束。

   &nbsp;

2. 在和**原作者的协商和正式约定**下，您可以按照新的约定，将本作品进行使用，包括商业使用。这相当于您单独从原作者手中获得了另一份使用协议。由于CC协议是一种许可协议而非限制协议，所以两者是不冲突的。

   &nbsp;

3. **如果您违反了本协议**，那么您获得的CC**许可证书**将立即**自动终止**。按照4.0协议，您有30天的窗口期可以修复您的失误以重新使得CC许可证书生效。

   如果您手上的CC许可证书因为您违反协议的行为而失效，您对于本作品的使用则是**无授权的，是侵权行为**。按照《中华人民共和国著作权法》，您会被追究责任，会面临**撤回侵权内容、公开致歉、补偿稿费**等合法要求。需要注意的是，30天的窗口期恢复证书仅仅在少量情况发挥作用，例如我在这30天中取消了所有获得本作品的途径，您可以通过窗口期重新获得协议而不需要重新授权。在您未恢复您的失误前，您手上的CC许可证书依然是无效的，将面临被追究法律责任的风险。

   请您不要冒险，如果我发现**未授权的行为**，将会及时固定证据链，并且**从重追究**。

&nbsp;

综合1,2,3可以看出来，对于各类公众平台或自媒体的转发或者改编，都有违反本协议NC条款的风险，而这是极其容易发生的。但如果您获得了新的授权，则完全不需要产生类似的担忧，因此强烈建议您在转发的时候联系原作者获得转发的授权。

&nbsp;

我采用CC协议的一个初衷就是希望更多的人能够从中学习到知识，让知识能够更加轻松地共享出去，CC协议保障了阅读者自由使用它的权力。在此之上，我对于本作品的传播自然是欢迎的，而且我也欢迎有人能够将其改编为视频。对NC和SA条款的保留，主要是我不希望自己接近于无偿的工作被其他人直接当作获得各种利益的手段。
