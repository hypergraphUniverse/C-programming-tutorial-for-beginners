# 第1章-C语言预备知识

Hi，希望你已经好好读过了第0章关于命令行的介绍，并且已经完成了我的任务。这些任务都非常少，熟练的人可以在5分钟之内就可以完成所有的第0章的任务。

&nbsp;

我非常不建议完全跳过某一个章节。虽然不要求你对所有的内容完全理解，但是不能完全没有对这方面的概念。下面我们将会讲解一些在学习C语言之前，不得不掌握的知识。

&nbsp;

## 1.1 一些不得不知的硬件知识

如果你要真正理解编程正在干什么，计算机硬件知识，其实是一个绕不开的砍。虽然你可以完全忽略，但是我并不推荐这样——死记硬背比深入理解效果差得多。

&nbsp;

**硬件**的一个特征是，它是一个实实在在存在的物品。如果你拆开电脑的话，就可以把它分解成很多个硬件部分。下面我们只讲三个计算机的和编程密切相关的硬件。其他的因为与编程关系不是非常紧密，就不在此介绍了。

三个关键**硬件**分别是**硬盘**，**内存**和**CPU**。

&nbsp;

### 硬盘

<p align="center">
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f8/Laptop-hard-drive-exposed.jpg/1004px-Laptop-hard-drive-exposed.jpg" width="300" />
  <p align="center">Wikipedia, Evan-Amos, under CC BY-SA 3.0</p>
</p>

**硬盘**（Hard disk）最关键的特征就是，它是一台计算机基本全部的数据保存的地方。

你现在正用着电脑，里面保存着你平时的所有数据。例如你写的Word文档，你下载的游戏，你收到的邮件。这些东西统统都在硬盘里面保存着。我们平时打开文件管理器的时候，在里面进行寻找和查看，就是在访问计算机的硬盘。

<img src=".\引用图片\001.png" style="float:left;" width="800" />

&nbsp;

**硬盘**还有一个特征，那就是当计算机完全关机之后，硬盘内部的数据仍然得到了保存。这个特征是**内存**和**CPU**都不拥有的。后两者一旦关机，内部的所有数据都会消失。这个独有的特征和硬盘本身的硬件结构有关。

简单一点介绍说，经典硬盘的存储原理是，在一张磁盘上产生磁化现象，通过磁化方向确定两种不同的状态，以此来存储信息。磁化现象产生之后可以自我保持，而不需要用电来进行维持，断电仍然能够保存信息。（下面这张图片仅仅希望展示我们用相反的磁化方向来表达数据，具体细节不需要知道。）

<p align="center">
  <img src="https://upload.wikimedia.org/wikipedia/commons/f/f3/MagneticMedia.svg" width="500" />
  <p align="center">Wikipedia, BlankAxolotl, under CC BY-SA 3.0</p>
</p>

&nbsp;

> ℹ：信息
>
> 一般而言，现在的笔记本电脑上面使用的SSD固态硬盘，则没有使用磁盘的磁化效应来进行数据存储，但是作为硬盘，它仍然是具有如上两个属性的：存储大量数据和断电保存数据。

&nbsp;

### CPU

<p align="center">
  <img src="https://upload.wikimedia.org/wikipedia/commons/d/dc/Intel_80486DX2_top.jpg" width="300" />
  <img src="https://upload.wikimedia.org/wikipedia/commons/e/e7/Intel_80486DX2_bottom.jpg" width="300" />
  <p align="center">Wikipedia, Andrew Dunn, under CC BY-SA 2.0</p>
</p>
&nbsp;

CPU(Central Processing Unit)又叫中央处理器，主要承担着计算机最为核心的两个任务：**解释指令**和**处理数据**。简单理解就是运算的中心。

&nbsp;

**解释指令**所处理的对象就是程序。所谓的**程序**，就是指挥CPU如何进行运作的一系列命令。

**解释指令**的具体含义是，编码为0和1的**程序**进入CPU以后，CPU通过电路将程序解释成一系列的具体操作，并且依次进行执行。

&nbsp;

**处理数据**这个概念中**数据**的定义是，按照某种方式进行保存的信息。

**处理数据**的具体含义是，CPU**解释指令**后，执行具体操作时，对某些**数据**进行的算术运算或其他操作，例如加减乘除，复制读写等等。

&nbsp;

同时CPU里面还会有少量的**寄存器**，主要用来临时保存即将运算的数据和刚刚运算完成的结论。

&nbsp;

下面这张图是一个极度简化的**CPU**的工作概念模型，其中两个大实边长方形部分，即程序保存位置和数据保存位置处于内存中，其他的部分则是CPU。

<img src=".\引用图片\002.png" style="float:left;" width="800" />

&nbsp;

### 内存

<p align="center">
  <img src="https://upload.wikimedia.org/wikipedia/commons/d/db/Swissbit_2GB_PC2-5300U-555.jpg" width="400" />
  <p align="center">Wikipedia, An-d, under CC BY-SA 3.0</p>
</p>
**内存**，更加专业的称呼叫做随机存取存储器(Random Access Memory)。主要的任务是，在**CPU**和**硬盘**之间承担中转的任务。

不论是程序还是数据，一般而言，数据的本体都在硬盘中。但是CPU需要立即处理的数据，需要立即使用的程序，还有CPU运算完成的结论，都会被放在内存里面。

&nbsp;

### 三者的比较和结合

我们从刚才的文字，我们可以明白这个关系:

存取操作速度：CPU>内存>硬盘

容量：硬盘>内存>CPU

&nbsp;

为什么要有这样的分级呢？一种简单的解释是，制造快速存取的硬件的成本太高了，如果全部使用快速存取的存储介质，可能一台电脑的价格要翻一百倍。工程师希望在效率和价格之间取一个折中点，因此就将硬件的读写速度分层，用相对较慢而便宜的介质来保存大量数据，仅仅留少量的高速空间来保留即将需要运算的数据。

当然，分级本身也是可以优化速度的。即使是同一种存储介质，存储容量和读取速度本身也是一对冲突的指标。空间越大，寻找特定数据的时间就越长，速度自然就下降了。现今的CPU内部也自带多级缓存，这些缓存之间也是按照空间越大，速度越慢的关系进行分级排列的。

下面是电脑中CPU，内存和硬盘的容量与速度之间的一个例子：

<img src=".\引用图片\003.png" style="float:left;" width="800" />

&nbsp;

在不考虑CPU多级缓存的前提下，我们也可以将计算机这三者的关系用下面这张模式图来表示（仍然是一个非常简化的模型）：

<p align="center">
  <img src=".\引用图片\004.png" width="300" />
</p>
&nbsp;


> ℹ：信息
>
> 看到上面这些介绍，是否觉得对平常使用的计算机有了更加深刻的认识呢？当然了，现实中的硬件则更加复杂，上面的讨论仅仅将最精髓、最重要的部分提取了出来。
>
> 如果系统地学习下来，要从逻辑门开始学习；认识寄存器，复用器解复用器等等基本元器件，认识状态机等模型；学习加法器乘法器等运算电路的设计；认识将执行任务和电路关系分开的通用运算器；然后了解汇编语言和电路的合作联系……
>
> 还有很多细节问题需要了解，例如说用于提升效率的并行流水线，以及并行流水线带来的各种流水线冲突；多级缓存的寻址方式，写入策略……
>
> 这样算下来，内容就很多了。现在为了学习编程，必须了解的就只有我讲解的这么多。不过如果日后要学习计算机专业的话，还会系统性地学习这些东西的。

&nbsp;

### 一个非常合适的比喻

上面的介绍是不是有些让人头疼，还是看不懂？我的建议是，尽量去一字一句读它。我已经尽量将语言简化了。不过考虑到这些东西可能“过于无聊”，这里还准备了一个更加形象的版本。

仅仅考虑这三个硬件（忽略CPU分级缓存），我们还可以做一个很恰当的比喻，来描述这三者的关系（当然已经有很多人说过这样类似的比喻了）。

不过为了让案例更加生动，我会将非常详细地叙述细节设定:

&nbsp;

在计算机中，**硬盘**是一个很大的书架，**内存**是一张桌子，**CPU**是用这两样东西工作的人。

<p align="center">
  <img src=".\引用图片\007.png" width="300" />
  <img src=".\引用图片\006.png" width="300" />
  <img src=".\引用图片\005.png" width="300" />
</p>

&nbsp;

书架里面放着两类文件。一种是指导CPU应该干什么的文件，也就是**程序**；另外一种是保存着各类需要处理的信息的文件，也就是**数据**。

<p align="center">
  <img src=".\引用图片\008.png" width="400" />
</p>

&nbsp;

这个房间里面有无限的草稿本和文件专用纸供应。

<p align="center">
  <img src=".\引用图片\009.png" width="400" />
</p>

&nbsp;

CPU是一个非常死板的人，它干活是这样干的：

CPU开始着手一项任务的时候，先从书架里面取出一些文件（既可能是程序也有可能是数据），并且把它誊抄到桌子上的草稿本上。这一步是最慢的，但是因为书架上可以存储很多文件，桌子没法全部放下，所以CPU不得不这样做。（对应前面模式图过程(1)）

<p align="center">
  <img src=".\引用图片\010.png" width="600" />
</p>

&nbsp;

书架上的文件誊抄完成之后，现在桌子上就拥有完整的数据和程序了。CPU就开始执行程序，它记下一些数据，并且按照程序的指导，对数据进行一些运算和操作。（对应前面模式图过程(2)）

<p align="center">
  <img src=".\引用图片\011.png" width="600" />
</p>

&nbsp;

因为心算的时候一次性记下的数据是有限的，CPU不得不过一会儿就将已经算好的临时数据记在草稿本上。（对应前面模式图过程(3)）

<p align="center">
  <img src=".\引用图片\012.png" width="600" />
</p>

&nbsp;

需要注意的是，CPU执行程序时，**解释指令**和**处理流程**的过程，就是不断地进行模式图中(2)(3)的流程。

<p align="center">
  <img src=".\引用图片\013.png" width="600" />
</p>


&nbsp;

当CPU完成了整个程序，并且程序要求将这一次的结论数据永久保存到书架里面，那么CPU就会把草稿纸上的内容誊抄回文件专用纸上，然后把旧文件换成新文件，存到书架上（当然，也有可能只保存新文件）。（对应前面模式图过程(4)）

<p align="center">
  <img src=".\引用图片\014.png" width="600" />
</p>
&nbsp;

我们也可以把这个流程拿到一起来看看：

<p align="center">
  <img src=".\引用图片\015.png" width="600" />
</p>


（当然这也是个非常简化的模型。作为网游，常常需要从网络中获取一些数据，要是这样讲解下来就复杂了。）

&nbsp;

## 1.2 编程究竟在干什么

知道了之前的一系列的硬件知识，我们就可以讲一讲我们编程究竟是在干什么了：

平时作为计算机的使用者，我们使用他人发布的程序来生成或者处理数据；

现在学习编程，就是我们自己写一个程序，处理自己想要处理的数据。

&nbsp;

如果按照之前的比喻来进行思考，意思就是，平常你拿着别人给你做好的紫色文件（别人已经编写好的程序）指挥CPU行动。

现在，你需要学着自己给CPU写一张紫色文件，让他按照你的意愿进行行动。

<p align="center">
  <img src=".\引用图片\016.png" width="400" />
  <p align="center">此处应该有拿道具的音效……</p>
</p>


&nbsp;

在正式学习之前，我们先来了解编程语言的一些分类。

&nbsp;

### 机器语言，汇编语言和高级语言

#### 机器语言和汇编语言

由于CPU实质上是一种电路，所以说只接受0和1作为程序输入。这种0和1组成的程序，我们将其称之为**机器语言**。

但是0和1这种语言难以记忆，因此人们将**机器语言**按照功能编成一些字母的简写。我们可以较为形象地用这种语言进行思考，这就是**汇编语言**。

实质上**汇编语言**是和**机器语言**一一对应的，可以互相直接翻译。一个不同的CPU设计结构，就有一种自己的机器语言，也就有它对应的汇编语言。

&nbsp;

我们举一个MMIX汇编语言的例子来欣赏一下互相翻译的流程。

因为原网站有版权限制，这里无法使用他的配图，但是这里提供了一个[链接](http://mmix.cs.hm.edu/doc/opcodes.html)，可以前去参考。

&nbsp;

我们举一个简单的**有符号整数**加法语句

```assembly
 ADD $3,$1,$2 
```

意思是：将一号寄存器$1和二号寄存器$2的有符号整数相加，结果保存到三号寄存器$3中

我们按照链接中的参照表以及一些其他的MMIX知识（这里不具体讲解过程），得到对应的十六进制编码和二进制编码。

```assembly
0x20030102                                 人们常常使用0x作为十六进制的前缀，用于标注进制避免歧义
0010 0000 0000 0011 0000 0001 0000 0010‬    这一行是二进制表达，和上一行仅仅是进制转换的运算关系而已
```

&nbsp;

> ℹ 信息
>
> 这里我们仅仅是欣赏一下对应过程，明白汇编语言和机器语言的等价性。具体怎么翻译还需要学一学MMIX。

> ⚠ 有限的介绍
>
> **有符号整数**，与之对应的是无符号整数。字面意思，有符号整数可以表示负数，而无符号整数只能是正数，我们之后会再谈它的一些性质。

&nbsp;

顺着之前的比喻说，汇编语言的地位，就和CPU能够看懂的紫色文件的语言非常接近，几乎是等价关系。

&nbsp;

#### 高级语言

汇编语言写程序常常是过于冗长的：例如说我们想要将两个数字相加然后获得他的结果。完整地做下来，汇编语言的需要进行如下的一系列操作：

1. 结合之前的程序，查看哪些寄存器现在没有被占用。发现寄存器$1,$2,$3目前都没有占用。
2. 将来自内存的值1输入到寄存器$1里面。

3. 将来自内存的值2输入到寄存器$2里面。

4. 寄存器$1和$2相加，结论放到$3寄存器里面。

5. 输出$3的值到内存中。

&nbsp;

我们很多时候真的不需要关心这种琐碎的细节，我只想要值加起来然后得到结果，并不关心具体使用了哪一个寄存器。因此我们希望一个东西能够帮助我们管理这种内容，这样编程者就有更多的精力去关注程序功能本身。

于是**高级语言**应运而生了。

&nbsp;

目前我们学习的的绝大多数编程语言，例如说即将学习的C，是**高级语言**。

例如说作为高级语言之一，C语言写出来的内容，叫做**源代码**。

**源代码**在这里可以理解为，用某种高级语言写出来的文本。这既然是一种文本，就并不能直接被CPU理解。C语言的**源代码**最终要经过**编译器**，将其翻译为**程序**。

**程序**，或者叫做可执行文件，其实也就是0和1组成的机器语言，也就是CPU能够理解执行的形式。

> ⚠ 有限的介绍
>
> **编译器**的工作流程实际上会更加复杂一些，我们在第二章还会提到他的具体工作模式。现在我们可以直接理解为，一种可以将C语言从**源代码**翻译到**程序**的东西。

&nbsp;

我们之后的学习中，都会使用变量等模型，并没有直接指挥寄存器。这也实际上意味着，学习硬件知识并非学习C语言的前提，C语言将硬件基本上隐藏起来了。但是如果我们能够对硬件有一些知识了解，对于学习理解C语言是十分有用的。

<p align="center">
  <img src=".\引用图片\017.png" width="400" />
</p>
> ⚠ 有限的介绍
>
> 很遗憾的是，这个配图并不完全正确，因为目前还不存在使用MMIX汇编语言的实体机（因为那个语言就是一个用于教学的思想实验），不过这张图旨在讲解两者的关系。

&nbsp;

## 1.3 一些不得不知的系统知识

我们刚才思考的模型，仅仅是一个单一的程序执行时的细节。

那么有一个问题来了：在程序开始之前以及程序完成之后，CPU在干什么呢？

或者换一个问法：我们平时双击某个exe打开了一个程序，但是双击之前这个程序还没有开启，那么这个双击又是谁在处理呢？

又或者接着之前的比喻换一个问法：这一句让CPU开始执行程序的话，是谁在喊呢？

<p align="center">
  <img src=".\引用图片\018.png" width="300" />
  <p align="center">场外神秘人物.jpg</p>
</p>

&nbsp;

答案就是：**操作系统**。

**操作系统**我们当然都认识，例如说Windows，MacOS，Linux是三大系列系统。操作系统已经成为了我们计算机中不可或缺的一部分了。

我们可以现在对操作系统进行初步的描述理解：**操作系统**是一种通用**程序**，用于实现计算机的基本常用功能。在此基础上，操作系统能够管理其他功能性程序的运行，以此达到更多的功能。

&nbsp;

其中的两个关键内容：**实现基本功能**，**管理程序运行**。

**实现基本功能**是指，我们对于一个正常电脑所拥有的功能的最低要求。例如说，电脑一打开总得有一个桌面，总得有一个磁盘管理的程序，总得把自己有些什么功能写在一个菜单上。这些是现代的操作系统为人们提供的最基础的服务了。

**管理程序运行**是指，操作系统是其他各种软件的基础。操作系统先运行，在此基础上操作管理其他的软件运行。例如说Office三件套，他们各自处理不同的办公需求，然而他们都是基于Windows系统进行运行的。我们需要开机进入操作系统之后，才能运行Office三件套。

<img src=".\引用图片\019.png" style="float:left;" width="600" />

&nbsp;

在此特地提醒一下，回忆第0章我们学习过的**命令行**。

**命令行**可以看作一种**操作系统**，因为它提供了管理计算机的基础功能，且能够在其之上运行**控制台程序**。实际上，在**用户图形界面**仍然未普及的时候，早期的计算机都使用命令行的形态作为操作系统。

不过，现在Windows上的命令行已经失去了一些底层功能，无法单独作为操作系统工作。但是我们仍然可以一定程度上将其视为一个操作系统，可以处理键盘输入，屏幕输出，运行和管理程序。可谓麻雀虽小，五脏俱全。

&nbsp;

在这里尤其需要指出**命令行**作为**操作系统**和**程序**之间的关系：

命令行是一种典型的单线程操作系统。当我们开机（开启命令行）后，就处于操作系统主线程上。主线程中，我们可以执行一系列的指令或者程序，并且观察结果。每当我执行一个程序后，命令行将会在此之上进入程序对应的任务，直到程序结束后，回到刚刚的状态里面。这种不断进入和退出就是这类系统的执行逻辑。如果你完成了第0章的任务，应该会对此现象有所感受。

<img src=".\引用图片\020.png" style="float:left;" width="700" />

&nbsp;

### 📄任务1.3.1-回答问题

这里的任务，对1.1-1.3的内容进行了考察。答案并不唯一。

请进入任务1.3.1，里面有简答题或者填空题。

&nbsp;

### 📄任务1.3.2-直接对内存动刀(选做)(超纲)

这个任务的指导不够详细，而且我们之前也没进行相关软件的操作讲解，超纲了。

不过这个是一个很有趣的探索题，能够更加深刻地了解程序运行的原理。

&nbsp;

我们在上面学习了CPU和内存互相存取的关系。

那么自然，打游戏的时候如果你想开挂，自然而言就会有一个思路就是，将内存上面的数据直接改掉。毕竟CPU能够记住的数字很少，你的血量作为中间数据，肯定是存在内存里面的。

假设这个游戏中，敌人每一次对你造成伤害都会让你的血量减少。那么你直接找到内存上血量的位置，把初始值改的很高，你不就无敌了吗？

于是我们欢迎改内存数据的主角——[Cheat Engine](https://cheatengine.org/)

<img src=".\引用图片\021.png" style="float:left;" width="600" />

由于这个任务是超纲任务，我对这个软件的操作不做过多的讲解。如果你想要做这个的话，也就说明你想要挑战自己。那么你即使看不懂我的讲解，也应该自己努力探索一下，找一些资料来学会操作。（或者下载一个中文版本的更加熟悉一些）

&nbsp;

任务文件夹里面有一个程序mission_1.3.2_crack shop.exe。双击即可运行。这个小游戏你没法正常通关，只有用Cheat Engine才能搞定。

其实你第一次打开cheat engine的时候他也会有一些教程，但是我这个程序更加简单一些。

我现在对流程略作叙述：

1. 首先点左上角绿色闪光按钮，弹出来的窗口中选择你想要开挂的进程，例如mission_1.3.2_crack shop.exe

2. 右侧Value文本框中输入你想要在内存中找的中间数据，例如说你现在拥有的钱的数量。

3. 点击First Scan(第一次寻找)，左侧列表就会弹出内存上现在是这个数据的位置。
4. 由于我的程序很简单，所以可以直接观察。在游戏中操作一下，使得游戏中想改掉的数值进行一下变化，回到Cheat Engine里面看看究竟哪一个数据是跟着变的。
5. 这个一直和程序中显示一致的数字就是内存上钱对应的临时数据了。你可以把这个地址拖到下面编辑框里面，改数值或者锁数值。
6. 于是你就把钱的数量在内存上改掉，成功开挂。

&nbsp;

如果成功，你会获得一串密码，作为你确实成功黑掉这个程序的证明。

&nbsp;

> ℹ 信息
>
> 实际上你现在不太了解编程的一些细节，所以做CE自带的tutorial也没有太大的意义。
>
> 现在主要是玩一玩，深化理解一下内存和CPU的关系。这个东西和学习编程也没啥关系，现在不讲也就永远不会讲了，也算是一个趣味题，让你多接触一些新鲜有趣的东西。
>
> &nbsp;
>
> 如果说你成功黑掉这个程序了，真的不要太自信。只有学习精通了编程，才能真的理解CE到底每个选项在干什么。现在编程都没有学，很多时候的操作就只是照猫画虎，到底干了什么，也是迷迷糊糊不知所以然。而且，即使学习了编程，也需要额外的学习——CE看上去操作很简单，但是实战下来，涉及到了汇编语言，涉及到了很多设计程序的经验，实际上要求使用者水平要高于正常的编程者。
>
> 另外，现在的游戏引擎动不动会产生很多中间数据，他们之间互相依赖的关系实在是很复杂，破解者需要使用很多技巧去找到“真正的临时数据”。另外还有游戏厂家自己防止破解所作的一些努力，让水平一般的破解者望而却步。这一切都需要很多精力。
>
> 即使我很熟悉C的编程了，在用CE的时候，也经常思路卡顿。真的，想要精通外挂，需要的水平实际上是很高的。

&nbsp;

## 1.4 第一次接触C语言

总算，闲扯了这么久，我们可以进入我们的主题：C语言。

我推荐直接从**开发集成环境**(IDE, integrated development environment)接触C语言。

**开发集成环境**（之后简称IDE）可以说就是写代码一站式服务程序，你写完了代码，可以直接在IDE上面**编译**。而且很多稍微复杂一点的选项也可以在IDE中图形化配置。可以说，选择了合适的IDE之后，就免去了很多麻烦。而这些麻烦通常会给初学者带来很多困惑和打击。

于是现在隆重推出我指定使用的IDE: [Dev-C++](https://sourceforge.net/projects/orwelldevcpp/files/latest/download)

安装时语言没有中文，下载安装完成之后，第一次启动程序配置的时候会让你选择语言，那里面是有中文的，里面选就是了。

好处：占用空间小，下载后立即使用，作为基本使用不需要更多的操作。

&nbsp;

### Dev-C++基本操作

进入Dev-C++程序之后，你通常需要新建一个源代码，这个就是初学时所需要的文件形式了

<img src=".\引用图片\022.png" style="float:left;" width="800" />

&nbsp;

界面中保存新建另存为什么的就不用介绍了。现在我们在下面随便打一些可以运行的代码，然后最重要的，你需要认识会伴随着我们学习一直要使用的是编译，运行和编译运行三个按钮。

如果你还没忘记掉之前的介绍的话，我们在下面写的文字是**源代码**，实际上是一种文本文件，而**编译**过程就是将**高级语言**的源代码转换成了**机器语言**，也就是**程序**。如果仅仅点击了运行，则会运行已经编译好的程序。编译运行就是结合两者。

<img src=".\引用图片\023.png" style="float:left;" width="800" />

&nbsp;

需要注意的是，执行这三个按钮之前需要对文件进行保存，保存的时候要存成C源码(后缀名.c)而非C++源码(后缀名.cpp)。程序默认保存成cpp源码，需要注意。

<img src=".\引用图片\024.png" style="float:left;" width="400" />

&nbsp;

### 认识最小的C语言程序

刚才那个随便打的代码，就是C语言的最小程序。我们不走寻常路，不去打印Hello world。毕竟对于C语言，就是一个Hello World也会一下子涌现出很多的不熟悉的东西。

```c
int main(void){
	return 0;
} 
```

&nbsp;

于是我们就从最小的内容开始讲解：

1. C语言的基本阅读

我们首先认识第一个概念，**语句**。

**语句**的定义是，**程序**中，实现一个特定功能的独立单位。我们可以类比一下，命令行中完成一个特定功能需要一个命令，例如ls，cd它们都是一个个命令；而C语言**程序**中完成一个特定功能的独立单位就是**语句**。

大多数情况下，一个**语句**的结尾需要加上一个分号表示一个语句的结束。这一点尤其在C这种没有排版限制的语言中非常重要。

所以我们也可以这样（不严谨地!）定义**语句**：两个分号之间的内容是一个语句。

```c
return 0;
```

例如，如上的"return 0;"就是一个语句。因为它是第一句语句，所以他前面就没有分号。

如果存在多个**语句**，那么程序就会从上至下，从左至右，依次执行每一个语句。

> ⚠ 有限的介绍
>
> C语言一共有六大类语句。
>
> 而其中的有一些语句不需要分号作为结束！这一点需要记住！但是作为初学者，一开始接触的所有基础的语句都会以分号做结束，所以我们暂时采用了这个不严谨的定义。在练习题中，你会看到一些不需要分号结束的语句。语句的严谨定义，还是实现一个特定功能的独立单位。之后我们会逐渐认识六种语句的。

&nbsp;

2. C源代码的**主函数**

```c
int main(void){...} 
```

因为缺乏很多必要知识，我们现在不做过多的解释，现在希望你记住少数的性质，先会使用它。

总之，如上这个形式就是一个**函数**的样子。这个函数的名字叫做main。在C语言中，名字叫main的函数有他的特殊地位，我们称之为**主函数**，**主函数**的特殊之处在于，它一定是整个程序的开头。

&nbsp;

```C
int main(void)
```

前面这一段是说明**主函数**性质的，它的具体名字我们之后再说。我们需要知道的是，它并不起到实际的执行效果，不是语句。目前你需要记住的唯一性质就是，函数结束之后，会**返回**一个**整数**。（**返回**的概念看后面）

&nbsp;

```c
{...}
```

后面一段大括号中包含的是**函数主体**，大括号中的内容是需要执行的**语句**。所有的**函数**执行**语句**的时候，都从大括号里面的第一个**语句**开始执行，主函数也不例外。

这里，这三个点的意思是里面会有一些内容。例如我们例子中的内容就是"return 0;"这一个语句。

当然，大括号里也可能有很多语句，或者还会有少量的其他东西。

&nbsp;

3. **主函数**的返回值

我们看完了函数，现在就需要看剩下的一句话，return 0；

```c
int main(void){
	return 0;     <--------其他部分都看完了，你需要看这一行
} 
```

return当然意思就是返回了，我们将这带有return的**语句**叫做**返回语句**。**返回语句**是**函数**所需要的一个特殊的语句。

1. 如果**函数**主体中遇见了**返回语句**，意味着函数就此结束。
2. **返回语句**会将return后面的内容返回到“函数外面”去。这里我们将0这个值返回到了“函数外面”。

&nbsp;

> ⚠ 有限的介绍
>
> 缺乏的知识太多了，但是我们必须要对这个进行讲解，正所谓万事开头难，但是总得有个开头。
>
> 所以我尽量忽略了很多现在不必要的概念。有一些话就讲解得比较模棱两可，实际上有更专业的说法，例如“这个函数的名字”，其实应该叫做函数的标识符；“前面这一段是说明主函数性质”其实叫做函数头；“后面的内容”,“返回到'外面'”，这些用语都不够专业。
>
> 但是上面已经有的内容本来都是难以理解的概念了，所以我们就不引入更多的概念了，我们会在后面重新学到。
>
> 关于**数据类型**我们会在第2章立马学到，对于上面出现的int和void你会有一个全面的认识。
>
> 关于**函数**我们之后会在第3章学到的，现在因为缺乏了太多的知识，还没法讲解。
>
> &nbsp;
>
> 在这里，你需要牢记两点：
>
> 1. **语句**是C语言程序中，实现功能的基本单位。它们常常但不一定用分号分割。
>
> 2. 带main的这一坨东西，叫做**主函数**。它是C语言程序的开头，具体而言，从它的花括号里面的第一个语句是C语言程序的开头。
>
> 你之后在学习了大多数概念之后，则会对这里有更多的了解。

&nbsp;

### 📄任务1.4.1-标注区分语句

这个任务看似复杂，因为你会看到很多很多不认识的代码。

但是它并没有超过你之前的认识。你不需要理解所有的内容（而且有一些代码也完全没有意义，且也故意用了很糟糕的排版）。你只需要将整个图进行标注，划分出每一个语句。

现在就是要锻炼一下你直觉性分割语句的能力，就像是你阅读中文，需要先把句子划分成单词。代码本身现在你还肯定不会。放心，你之后会读懂这里的全部内容的。

请使用画图软件，仿照着示例，进行标注。

&nbsp;

### 程序给操作系统的返回值

我们在讲解C最小程序模棱两可地说到了，**返回语句**会将return后面的内容返回到“函数外面”去。

实在是因为很多概念的缺失，所以没法用术语来描述这个“函数外面”到底是个啥，我都迫不得已用了引号来表达一下这个概念。但是我们关于最小程序的返回还是可以讲一讲的。

&nbsp;

我们在介绍**操作系统**，介绍命令行的时候，就知道了这个模型：

<img src=".\引用图片\020.png" style="float:left;" width="600" />

我们首先是打开了操作系统主程序。对于编写C程序的时候，就是打开了命令行。然后我们在命令行中执行了程序。程序结束后，命令行又回到了操作系统主线程。

我们又知道，**主函数**是C语言的开头。实际上我们还可以说，主函数也是C语言的结尾。我们如果在主函数中遇见了**返回语句**，意味着主函数的结束，也就意味着程序的结束，那么命令行就会返回操作系统主线程。

没有错，**返回语句**会将return后面的内容返回到“函数外面”去。这个“函数外面”对于**主函数**而言，就是命令行操作系统主线程。0被返回到了命令行的操作系统主线程，也就是平时闪着光标等待你输入新指令的界面中。

&nbsp;

对于这个C最小程序，打开主函数第一句就是返回语句，立马结束了，所以这个最小程序我们可以画一张这样的概念图：

<img src=".\引用图片\025.png" style="float:left;" width="600" />

&nbsp;

### 📄任务1.4.2-Dev-C++中测试返回值

我们不妨就用Dev-C++来看看命令行接收到的返回值是什么，这一点在Dev-C++中很好查看。

&nbsp;

用Dev-C++打开任务1.4.2中的mission_1.4.2.c，其实就是上面讲解的最小程序的代码。点击上方"编译运行"，这个代码就编译成程序，而且自动运行了。Dev-C++会为你自动打开一个cmd命令行，开始执行程序。

<img src=".\引用图片\026.png" style="float:left;" width="800" />

&nbsp;

其中执行结果里面的打红框的部分不是你的程序自己有的内容，是Dev-C++为你加上去的显示。显示的内容就是你的程序的返回值。

你可以尝试着改变程序中return后面的数字。再编译运行一下，看一看返回值是不是发生了变化。

&nbsp;

### 主函数返回值究竟在干啥

这里，你可能早就有一些疑惑了，这个返回值到底干什么用的，我不就是改了一个数字吗？有什么好玩的吗？

最直接的答案就是，对于**控制台程序**而言，返回值可以给命令行**操作系统**提供一个渠道，表明程序退出的时候究竟是正常退出，还是遇见了一些问题之后被迫退出。这一点，对于命令行中多程序联合运行有着很大的帮助。

例如说，一个控制台程序的任务是安装一个软件X，但是安装这个软件需要先安装A，B，C三个软件作为前提条件。那么这个X软件安装程序首先就会检查A，B，C三个软件是否存在，如果不存在，则先运行安装这三个软件的程序，然后进行等待（因为命令行是单线程系统）。

<p align="center">
  <img src=".\引用图片\028.png" width="500" />
</p>

&nbsp;

这个时候如果A软件的安装程序结束了，并不意味着万事大吉。有可能是A软件安装错误后程序被迫退出了。但是X软件的安装程序无从知晓。

<p align="center">
  <img src=".\引用图片\029.png" width="500" />
</p>

&nbsp;

所以这个时候，返回值就起到了很好的通讯作用：X软件安装程序只需要和A软件安装程序约定好，不同的返回值代表了不同的完成状态，X安装程序在**A安装程序结束**之后，查看一下它**给命令行的返回值**，不就知道了A是不是成功安装了吗？

<p align="center">
  <img src=".\引用图片\030.png" width="300" />
    <img src=".\引用图片\031.png" width="300" />
</p>


&nbsp;

&nbsp;

在Windows系统中，人们已经约定好了，返回值为0表示程序成功退出，其他的返回值的含义则由编程者自我规定。如果说一个程序确实会被其他程序调用，只需要查看它的编程者发布的返回值具体含义，就可以区分出各种程序运行状态了。

&nbsp;

我们之前说过，命令行中所有的命令也是一种程序，这个程序自然也会有返回值。我们举一个命令的例子，这个命令只能在老式的cmd命令行中运行：color

这个命令就是用来改变控制台的全局颜色的。例如"color 0A"就可以将背景变成黑色，字变成绿色。

如果我们cmd命令行中输入"color -help"，则可以看到一个基础说明。

<img src=".\引用图片\027.png" style="float:left;" width="800" />

&nbsp;

当然你可以开始改颜色玩，但是我们需要关注的是最后的一句话：如果尝试使用相同的颜色执行，则会ERRORLEVEL设置为1。在命令行中，ERRORLEVEL的意思就是程序的返回值。

因为前景和背景颜色相同的话就会页面变成同一个颜色，自然会引起混乱，因此COLOR程序认为这不行，拒绝改变颜色。但是它要向其他程序说明自己是"意识到了错误，于是强制退出"，因此规定这种情况下，返回值设置为1，向其他运行它的程序表示这个是一种错误的退出状态。

这就是COLOR程序的非正常返回值的规定，也就是返回值的用处。对于其他较为复杂的程序，例如xcopy复制(copy的加强版)，则会有更多的异常情况，在[参考资料](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/xcopy)中可以查阅。不过已经扯远了，现在就不多做讲解了。

&nbsp;

作为个人编程学习，你当然不太可能让你的程序被别人调用😂。但是我仍然建议培养习惯，至少要做到正常情况下的程序退出返回0。异常情况下的退出返回值则随自己规定。

&nbsp;

> ⚠ 易错
>
> 只有**主函数**的返回（即主函数中的return语句）才表示给系统返回程序的退出状态。你可能以后会在其他地方遇到return语句，例如自定义的函数里面，而那些则和操作系统无关。因为只有**主函数**的”外面“是命令行。
>
> 需要小心，不要错误地认为只要是出现了return语句就表示给系统返回运行状态。

> ℹ 首次出现 : 易错
>
> 如字面意思，提醒你有些时候可能会误解原文的意思。

&nbsp;

### 📄任务1.4.3-命令行测试返回值

IDE为我们提供了非常便捷的方法可以直接看到返回值，但是这一点并不适用于已经编译完成的exe程序。如果需要看成品exe的返回值，我们需要在命令行中进行操控。

具体操作需要用到第0章命令行批处理文件的使用，即0.3。如果忘了可以现在去复习一下。

&nbsp;

查看返回值需要使用到批处理文件中的变量%ERRORLEVEL%。在执行完了程序之后，我们立即查看这个变量，就得到了刚刚结束了这个程序之后的返回值。这个变量我们需要把它直接输出，所以我们要用echo指令来显示它。

&nbsp;

mission_1.4.3.exe是一个程序，它什么都没有做，但是返回了一个值给控制台，你需要看到这个返回值是多少。

你需要做的是：

1. 参照0.3中建立批处理文件的方法，在任务文件夹1.4.3中建立一个批处理文件。
2. 你需要使用如下的代码来首先调用程序mission_1.4.3.exe，然后查看返回值。

```powershell
@mission_1.4.3.exe
@echo %ERRORLEVEL%
```

运行这个批处理文件，然后你就可以查看到ERRORLEVEL具体是多少了。

&nbsp;

### 一个大坑：啥都看不到

我知道有很多人想要直接双击刚刚建立好的bat批处理文件，然后发现什么都看不到。毕竟双击运行是我们的直觉，而且我也只是说了”运行这个批处理文件“。

&nbsp;

同样的情况发生在了mission_0.1中，如果你不用命令行，就会漏掉里面的密码。这是我用来强迫你使用命令行打开它刻意设置的障碍。如果你联想能力丰富一些，你会联想到这个任务，尝试着先打开命令行，然后命令行调用bat文件，就可以看到结论了。这是一个思路。

但是你一想，唉不对啊，任务1.3.2（可能因为超纲就没有做）的游戏为什么双击之后可以运行，而且没有这样的问题啊？这是怎么回事？

其实是因为我在程序里面手动加入了几个停止点，对应的是命令行中的pause命令。(其实你在1.4.1最后的一道题，看的就是这个小游戏的代码)

```c
system("pause");
```

<img src=".\引用图片\033.png" style="float:left;" width="800" />

这就是C语言中使用控制台pause的方法，我们现在不需要去深入研究它。你需要知道的是，如果遇见这个**语句**，控制台就会出现“请按任意键继续...”的字样。

&nbsp;

如果你仔细一点，发现0.3介绍批处理文件时，我的例子里面也使用了一个pause。你如果尝试着在你的批处理文件最后加入pause语句，那么你算是提前发现了这个方法。

```powershell
@mission_1.4.3.exe
@echo %ERRORLEVEL%
@pause
```

这下双击就可以打开你的文件，而且还可以看到结论了。

&nbsp;

不过这里希望讲的是，为什么会出现这些现象？

其实回答还是涉及到使用到我们关于操作系统的知识。

&nbsp;

你现在正在使用的是Windows 10系统。这个系统就是管理你所有程序的基础。**命令行**，我们平时在编程的时候可以认为它就是承载我们**控制台程序**的**操作系统**，但是实际上**命令行**如今也只是Windows系统上运行的一个**程序**而已，被Windows 10这个操作系统管理。

这也意味着，Windows 10系统才是最底层的系统，双击一个**控制台应用程序**（或者批处理文件，也叫bat文件）的时候，首先打开的是**命令行**，然后命令行再打开**程序**。如果程序执行完成，命令行也就自动退出，窗口消失。

这也意味着，对于各种最后不带有pause的程序，程序一旦执行结束，程序和控制台的窗口就马上消失了。你就很有可能会少看到一部份信息。

<img src=".\引用图片\035.png" style="float:left;" width="600" />

<img src=".\引用图片\034.png" style="float:left;" width="600" />

&nbsp;

其实这个问题也早有人注意到了。

对于IDE，例如说Dev-C++，它预料到这个事情是经常出现的，因此也有对策。

一般而言，在程序中使用pause是一个非常糟糕的行为(例如说在算法竞赛的时候，坚决不能在提交的代码里使用pause，否则会导致自动判分机器无法判分；实际上在各种成品程序中，pause都是很少见的。)

所以，Dev-C++就在你使用“运行”或者“编译运行”的时候，给你附加上了查看返回值和自动暂停的两个功能。这一点我们之前已经见过了。下面这个大红框就是Dev-C++自带的暂停功能，这样就保证了你不会漏掉任何数据。

<img src=".\引用图片\036.png" style="float:left;" width="800" />

<img src=".\引用图片\026.png" style="float:left;" width="800" />

&nbsp;

> ℹ 信息
>
> 如果你直接在命令行中写"echo %ERRORLEVEL%"，则会得到报错的警告。因为%ERRORLEVEL%这种东西是特属于**批处理文件**（bat文件）的变量。
>
> 其实有一种替代的方法，可以在命令行中使用：在PowerShell中执行完了程序之后，直接使用命令"echo $LastExitCode"也可以看到返回值。
>
> 只不过使用bat最方便的地方在于，可以直接双击，bat帮你运行了程序之后，立马获得结论。

&nbsp;

### 之后一些常用的概念模型

**这里的内容十分重要!** 因为有一些文字和概念非常枯燥，所以我会用如下的两种配图模型来和你进行补充解释。我会把我使用这些配图的每一个细节进行解释，希望你能够看清楚。

如果你跳过了这里，之后出现一些配图看的半懂不懂，就失去了看配图的意义。

&nbsp;

#### 时序图模型

你之前已经看到我画的一些时序图了。之前涉及到操作系统的时候，程序之间的关系就用了时序图来进行展示。

<p align="center">
  <img src=".\引用图片\020.png" width="250" />
  <img src=".\引用图片\028.png" width="250" />
   <img src=".\引用图片\035.png" width="250" />
</p>

一般而言，这种图从左往右看，每一个横行上标注了这个程序究竟是什么。越靠下的就越基础，越先被执行，有一些向上向下的箭头，就表示这个程序是的开始和结束。箭头直接也间接表示了一些依赖关系。

我在画图的时候，为了展现出命令行一次只能有一个程序在运作，因此当某个程序在运作，其他的程序在等待的时候，就会画成虚线。因为最右边那个图中，现在的操作系统一般是多线程系统（你可以同时开多个程序），所以Win10操作系统就“长得很高”，在上面就可以向右发生出多个箭头，每个箭头就是一个在Win10系统上运行的程序。只不过在这个地方，我们不需要关注其他的程序。

这种画图一般而言倒是没有一个什么特定的标准，画起来比较随性，所以有一些就是我自己的规定，其实看的时候也基本靠直觉感受。

你主要需要从这种**时序图**中看出事情发生的先后顺序，以及他们之间有可能的依赖关系。

&nbsp;

#### 概念分类/思维导图

概念分类，其实说来每个人都会。当我们拿到很多概念的时候，就会习惯性地理解概念，并且尝试整理出一张网络。有些人会绘制成思维导图的形式。我也会采用类似的形式。

不过我在这里需要说明的一点是，我赞同给自己的笔记中绘制一个完整的思维导图，但是反对将一个很大的思维导图直接拿出来作为给他人的讲解。因为思维导图本身是极度精简的，而且也一定程度上是个人化的。只有你自己才容易理解自己绘制的思维导图所拥有的全部信息。在给别人看的时候，别人则只能从字面上理解，只能看出一些简单的从属关系，失去了背后的很多隐藏的信息。

现在，我先给出一个我们已经学习过的语法知识的概念分类。

&nbsp;

> **概念分类：语法知识 V1**
>
> <p align="center">
> 	<img src=".\引用图片\037.png" width="500" />
> </p>

其中一些约定图示：

这里我们可以从概念分类图中看到语法成分的从属关系，能够将整个程序不断分割成小成分，分出层级关系。（之前你就在练习分割语句）

如果有一些内容我们暂时没有讲解，但是已经可以拿来占位了，那么我会写出名字，但是用灰色标出来。如果有很多我们还不知道的语法成分，就简写成省略号。之后我们会慢慢地解锁这些灰色位置的。

蓝色的框是一些临时的强调，写的也比较随性，主要是起到辅助理解的作用。

需要注意的是，这个导图中每一个词，通常都是之前已经出现的的**粗体**！这意味着这些关键词背后都有一些他的特有定义和内涵！由于导图空间紧凑，不能写出每一个关键词的定义，因此看导图的时候，一定要时时回忆这些关键词的实际定义，才能够从这个图中看到更多的信息。

记住，你需要从这种**概念分类**中看到其中的关键词的从属关系，同时，你需要联想到每一个关键词的定义。

&nbsp;

#### 程序运行模型

**程序运行模型会在后面多次使用到!** 所以不要忽略了它。

程序运行模式旨在提供一种非常图形化的方式，来全方面的理解每一句程序背后究竟发生了什么。

我们之前知道了（这些话，我已经翻来覆去说过很多次，但是还是要强调），**程序**就是就是指挥CPU如何进行运作的一系列命令。CPU的一个任务，**解释指令**，就是指CPU通过电路，将**程序**解释成一系列的具体操作。这些操作，则会对**数据**进行算术运算或者其他操作。这样的过程就是CPU的另外一个任务，**处理数据**。

由于CPU能存的东西很少，然而硬盘又太慢，所以执行**程序**的时候，绝大多数的**数据**都会在内存上等待CPU的不断存取和写入。

&nbsp;

因此我们如果要一句一句理解整个程序的流程，就需要“假装自己是CPU，按照程序的指导，开始管理内存”。这就是我设计这个程序运行模型的初衷。

&nbsp;

> ⚙ 程序运行模型构建
>
> **基础界面**
>
> 基础界面现在只有两个部分：左侧是代码界面，放着的是我们需要分析的代码。右侧是内存界面，是分析过程中的中间数据所集中的地方。
>
> <p align="center">
> 	<img src=".\引用图片\038.png" width="500" />
> </p>
>
> **代码窗口**
>
> 左侧是代码窗口。我们要分析的代码就会在这里。“正在执行”的代码会被高亮标注出来。
>
> **内存窗口**
>
> 右侧是内存窗口。按照我们之前对程序运行的理解，程序所有需要处理的数据都在内存里面。
>
> &nbsp;
>
> **两者合作关系**
>
> <p align="center">
> 	<img src=".\引用图片\039.gif" width="500" />
> </p>
> 随着左侧的代码一行一行地进行执行，右侧的内存中的数据会发生不断的变化。这就代表了程序对于内存上数据的操作，也就是程序运行的本质。
>
> 上面这个动画，仅仅是一个示范，大概有这种“一一对应”的感觉就好了。

&nbsp;

> ℹ 首次出现：程序运行模型构建
>
> 对我自己提出来的这个程序运行模型进行定义或者拓展。
>
> 以上仅仅是现在整出来的几个先期预览图，大体上是这样的，我还在寻找适合的表达方式，尤其是制图方式，因此这一部分在**外观上可能会发生一些细节的变化**。（我也在考虑展示方式，如果有什么建议可以联系我）

&nbsp;

这个模型会像上面这样，不断增加定义（实际上现在只是个预览，我们从第2章开始，开始正式学习C，也就开始研究起这个模型）。现在你知道的很少，所以一次性给太多内容没有意义，我们后来会不断进行模型的填充构建。

有一个建议就是，你要先学会这个模型图，先尝试着用如上的这种图形化的方式对程序进行理解。之后再学会脱离上面这种图，开始直接抽象思考（之后随着我们学得内容变多，以及程序变越长，整个程序在这个模型下开始变得冗长复杂，不再具有可读性，程序运行模型就比较适合局部的复杂小分析）。

&nbsp;

> **程序运行模型：最小C程序**
>
> <p align="center">
> 	<img src=".\引用图片\040.gif" width="500" />
> </p>
> 因为这个程序实际上什么都没有做，从第一句开始，遇到的立马就是return 0，所以程序立马终止，内存里面什么都没有发生（真是寂寞啊……）
>
> 用了这么多种方式来理解这个最小程序，是不是有些感觉了呢？
>
> 由于在我们的编程中，返回值一般是不会用到的，所以之后的界面中我们一般也就不会去讨论返回值。

&nbsp;

你需要从**程序运行模型**中，图形化地理解程序每一步的运行流程。按照我给出来的指导操作即可。

&nbsp;

#### 其他零散的概念图

<p align="center">
  <img src=".\引用图片\004.png" width="150" />
  <img src=".\引用图片\002.png" width="300" />
  <img src=".\引用图片\003.png" width="300" />
</p>


其他还有一些很零散的概念图，则就靠着直觉见招拆招吧。很多其实也都比较随意，都是配合着前后文字可以一起理解的。

&nbsp;

## 1.5 课后闲聊

啊，首先，总算这一章讲完了，除去法律声明，文字统计器居然写着有17205个单词，不过算出来也就是五六章网络小说的长度（起点对作家的要求是建议日更一章3000字左右）。

&nbsp;

这一章的内容远远超出了我一开始的提纲。毕竟写着写着就开始想”如果我是学生，我肯定会疑惑，为什么会这样“。于是篇幅就不断膨胀，远高于预期。

而且我还需要考虑到目前讲解的程度和后面的扩展问题。一开始就扔出大堆概念是不对的，这只会让人产生一种，这些字我都认识，但是合在一起我就是读不懂的困惑。我还是秉承一个原则，尽量通过朴实的语言来定义最初的一些概念，等各位读者掌握了这个概念以后，再基于这些概念开始构建概念的网络。同时，加上各种案例来辅助解释。就避免了空谈概念，旧的概念的出现只是为了定义新概念的情况。

&nbsp;

如果你能够仔细研读，会发现这些知识的组织顺序其实是非常精巧的，它们恰到好处地辅助了你的理解。

例如说我们接触到的唯一一个正经的C代码，最小程序，里面的**返回值**问题，算是讲到透彻之处了。但是如果你不知道**操作系统**的意义，你怎么能够理解返回值的精妙之处呢？

例如说我们讲到了按下"编译运行"按钮之后，C**源代码**就会被**编译**成程序，然后通过**命令行**打开运行。这仅仅是一个简单的操作，但是背后的现象就很多。

如果要理解**编译**，就需要理解知道**源代码（高级语言）**和**程序（机器语言）**的转换关系；要理解为什么有这个转化关系，就需要知道**CPU、内存和硬盘**的工作关系。如果你想要知道程序为什么要在这个黑色界面下运行，就需要理解**命令行**作为**操作系统**和**程序**的关系；要理解操作系统和程序，还是绕不开硬件问题；而且，要明白命令行究竟是啥，就要先知道命令行本身的操控。

只有你学习了之前的基础知识，你才能够在看见后面这些解释的时候，有一种豁然开朗的感受。如果我在什么都不说的情况下，直接抛出“返回值将数值返回至命令行”这种定义，不知道这这些前提知识的人究竟又会有怎样的理解呢？

<img src=".\引用图片\032.png" style="float:left;" width="600" />

很遗憾的是，这些知识几乎不被大学计算机老师提起，包括大量“适合初学者”的经典入门C语言教材也经常忽视这个问题。但是这些知识一旦缺乏，则会对编程的学习带来极大的困惑。另一方面，现在的系统越来越方便，越来越成熟。因此在日常中接触到这些知识的机会就越来越少。

&nbsp;

面对同样一句话，对相关领域完全不了解的人最多能够字面意思上理解这句话。但是懂行的人就能联想到更多，它明白哪些是关键词，背后各自有什么现象和意义，同时还可以根据自身的经验对这个现象举出一些自己见到的案例，并且做出一些自己的阐释。

写专业书籍的人常常认为，自己这一句话足够精简又足够表达含义，殊不知新手们根本不具备自己所拥有的各种常识，根本无法从同样一句话中还原出自己本身想要表达的含义。于是，本来懂了的人明白这个意思了，真不懂的人还是不懂。

我在写文章尽量去充分考虑这个问题，在每一处引入新概念的时候，都会仔细斟酌，里面是否隐藏了一些其他常识性背景，是否依赖于其他专业定义。如果有，是不是非要现在讲解，哪些不得不引入，哪些可以缓一下等到知识足够了再引入。

&nbsp;

我们再看看这样一个例子：

著名的C语言入门教程之一中有着这样的内容(这种内容会出现在第一个例程，也就是”一个简单的Hello World“程序里面)：

> int num;   声明
>
> 该声明表示，将使用一个名为num的变量，而且num是int(整数)类型
>
> num=1;   赋值表达式语句
>
> 语句num=1;把1赋给名为num的变量
>
> printf("I am simple");
>
> 该语句使用printf函数，在屏幕上显示I am simple，光标停在同一行。printf是标准的C库函数。在程序中使用函数叫做调用函数。
>
> ...
>
> ——《C Primer Plus 第六版》第二章

什么是声明，变量是什么？那么什么是int整数类型，类型是什么鬼，和变量有什么关系？赋值表达式，表达式就是字面理解吗？说到C库函数，函数是什么，库函数又是什么？

这些看似平凡的名词，在C语言中都有其特殊的定义，每一个都是一个知识点。这个地方就讲了这么一句，剩下的全靠想象。要解答这些内心中的疑惑，非要把后面好几章学完才算勉勉强强能懂。那一开始就引入这些抽象概念究竟是图个啥？

其中的一些术语，我现在还没有引入。我在后面的章节中慢慢“解锁”他们，一个一个进行讲解，一点点从底部构建知识体系。

&nbsp;

回过头来再说说刚才这本书。

更加好玩的是，这本书在后面几页开始讲解main函数的几种写法：

int main(void)最标准，int main()也行，main()将将就就能容忍，void main()已经很老很少用，而且被认为有问题了。

天哪，这些细节区别不是只有理解了函数和变量类型才能讲的东西吗？你给初学者讲这些，真的有人听懂了其中的微妙区别吗？这就相当于你硬拉着一个大字不识的人，就开始讲回的四种写法一样。被拉来的人没把你揍一顿都算有礼貌的了。

我在我的教程中将很少纠结回的四个写法一类的问题。这个内容固然重要，但是对于新手来说，都是细枝末节的事情，以后有机会再学也行。现在需要分清楚轻重缓急，把最重要的骨架建成，有了一个能够填充的知识框架，之后再自己学习就轻松了。

&nbsp;

所以编程给很多人带来挫败感并不是因为它真的难，而是因为缺乏了一些急需了解但无从得知的知识。除非你和我一样本身是计算机的爱好者，没事就喜欢折腾这些，而且阅读相关的文章，才会拥有足够支撑自己学习编程的常识积累。

&nbsp;

&nbsp;

同时，我也第一次尝试着自己绘图，希望使用一种较为愉快的方式来让人看懂大篇的抽象概念。不论是对读者还是我，这都算一个惊喜吧。我本来预计本文基本上都是抽象概念图的，结果试着画了一下插画，自己都没有想到能画这么多。也算是一个意外的质量提升。

但是估计这样的绘图只会在第一章里面出现这么频繁。这样很花时间，而且这种方式的信息密度还是太低了，之后使用抽象模型还是会比较常见。

之后的程序抽象模型具体用什么方式进行展示，我也需要进行一些斟酌。我也要和使用工具进行一下磨合，一个动画就整了一上午。而且我平时还有很多工作要做，因此也许下周就没有更新了。咕咕咕……

<p align="center">
  <img src=".\引用图片\041.png" width="350" />
</p>


&nbsp;

希望各位能够在自学计算机语言的路上共勉。编程并不难，只要摸到了门路就走的很快。

------

作者 - Author: Thomas Yao

GitHub名 - GitHub username: [hypergraphUniverse](https://github.com/hypergraphUniverse)

联系作者邮箱 - Email：hypergraphUniverse@outlook.com

![](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png)

除非另有说明或授权，本文档中的内容，包括但不限于文字以及原创图片按照[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)协议发布。请在遵守协议的情况下使用本文档，请注意下方对某些情况的法律提醒，**尤其**是在各类**自媒体平台上转发**的说明。请适当且明显地标注出处。

This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy of this license, visit [http://creativecommons.org/licenses/by-nc-sa/4.0/](http://creativecommons.org/licenses/by-nc-sa/4.0/) or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA. Please indicate the source clearly and appropriately when using. 

&nbsp;

法律提醒：

CC协议对于作品的转载与使用的约束相较于传统版权较为宽松，但是您仍然需要在使用的时候严格遵守协议，充分尊重版权。下面的文字，提供了详细的解释，希望您能够阅读后注意。如果如下文本的解释与原[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)协议有出入，请以原协议解释为准。

&nbsp;

本协议允许您对于本作品进行使用以及改编，但是您需要在使用、改编、再发布的过程中遵守以下的要求：

1. **保留著名权**。您使用本作品的行为必须给出适当的**原作者署名**，以及提供指向**本许可协议的链接**，同时**标明是否**对原始作品作了**修改**。

   适当的著名包括但不限于原作者的名字，以及指向原作品的链接等。这里建议您在转载过程中，至少要加入如上的两个原作者信息。且请您务必在显著的位置上进行原作者著名。

2. **非商用**。您不得将本作品以及基于本作品的改编内容用于商用目的。

   需要注意的是，商用目的**并非仅仅意味着获得金钱**的收入，在转发到自媒体平台上时尤其需要注意，详情参见后面的注意事项。

3. **遵守同协议**。如果您再混合、转换或者基于本作品进行创作，您必须**基于与原先许可协议相同的许可协议**分发您贡献的作品。

   您可以在Common Creative官网上找到和CC BY-NC-SA 4.0相兼容的协议。

&nbsp;

您需要注意的一些事情：

1. 非商用（NC）的限制并非仅仅意味着直接的金钱收入。非商用的限制对象包括了直接或者非直接获得利益。

   很明显，在没有原作者的授权下，您**不能**将作为**收费文章**转发，否则违反了本协议；如果您将本文章以**免费文章**的形式转发于某种形式的自媒体，其获得的**观众打赏，流量分成或者广告分成**仍然属于一种商业利益，其也是违反本协议的非商业限制要求的；即使您**关闭**掉了打赏或者广告等**收益功能**，并未从中获得任何直接的金钱利益，您仍然有利用本文章**提高您知名度**的嫌疑，其也会被视作一种商业利益。即使最终本作品**未给您带来任何实际的流量**，您实际上已违反了本协议。

   如果您将本作品进行**改编**，例如制作成视频，将其发布在任一平台上，您仍然面对如上相同的情况。且改编人不得不面对SA条款带来的更多约束。

   非商用协议也并**不豁免**您将本作品在**教育行业中的使用**。因为NC条款是基于目的而非身份进行定义的。

   很明显，收费的培训机构是无法直接使用本材料的，因为您将这份材料转换为了商业利益。但是，本协议并未限制您将本作品列入您向学生分发的推荐读物清单中，因为您并未在这个行为上进行任何涉及本材料的发布行为。

   &nbsp;

2. 在和**原作者的协商和正式约定**下，您可以按照新的约定，将本作品进行使用，包括商业使用。这相当于您单独从原作者手中获得了另一份使用协议。由于CC协议是一种许可协议而非限制协议，所以两者是不冲突的。

   &nbsp;

3. **如果您违反了本协议**，那么您获得的CC**许可证书**将立即**自动终止**。按照4.0协议，您有30天的窗口期可以修复您的失误以重新使得CC许可证书生效。

   如果您手上的CC许可证书因为您违反协议的行为而失效，您对于本作品的使用则是**无授权的，是侵权行为**。按照《中华人民共和国著作权法》（如果您不是中国人，仍然会因为中国加入了《保护文学和艺术作品伯尔尼公约》，适用于您本国的著作权相关法规。世界上仅有少数国家未加入此公约），您会被追究责任，会面临**撤回侵权内容、公开致歉、补偿稿费**等合法要求。需要注意的是，30天的窗口期恢复证书仅仅在少量情况发挥作用，例如我在这30天中取消了所有获得本作品的途径，您可以通过窗口期重新获得协议而不需要重新授权。在您未恢复您的失误前，您手上的CC许可证书依然是无效的，将面临被追究法律责任的风险。

   请您不要冒险，如果我发现**未授权的行为**，将会及时固定证据链，并且**从重追究**。

&nbsp;

综合1,2,3可以看出来，对于各类公众平台或自媒体的转发或者改编，都有违反本协议NC条款的风险，而这是极其容易发生的。但如果您获得了新的授权，则完全不需要产生类似的担忧，因此强烈建议您在转发的时候联系原作者获得更多的授权。

&nbsp;

我采用CC协议的一个初衷就是希望更多的人能够从中学习到知识，让知识能够更加轻松地共享出去，CC协议保障了阅读者自由使用它的权力。在此之上，我对于本作品的传播自然是欢迎的，而且我也欢迎有人能够将其改编为视频。对NC和SA条款的保留，主要是我不希望自己接近于无偿的工作被其他人直接当作获得各种利益的手段。
