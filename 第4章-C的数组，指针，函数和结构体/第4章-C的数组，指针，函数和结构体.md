# 第4章-C的数组，指针，函数和结构体

上一个章节结束之后，你就已经有基本的编程能力了，现在我们要针对C语言更多的功能进行学习。这一部分学习完成之后，你就学会了C语言所有的基础功能。此次内容偏长，尤其是4.4进阶话题的信息密度极大，但是为了讲解的完整性就不再分开。因此也可以将本章分作两次阅读。


如果说你觉得编程有一些困难，可以前来问我，而且这周，你可以参考附件3-快速语言参考表，辅助你的编程，快速排查编程中出现的问题。

&nbsp;

## 4.1 数组、字符串指针

之前讨论关于数组的内容，我们基本上明白了一个逻辑关系：**数组**的本质是内存上一段连续的空间，以及一个拥有标识符，指向第一个地址的**指针**。**指针**则是保存了一个内存地址的变量；指针保存的地址，也称**指针指向了这个地址**。指针指向的位置的数据类型假设为int，那么这个指针的数据类型则叫做**int的指针类型**或者**int*类型**。

<p align="center">
<img src=".\引用图片\001.png" width="600" />
</p>

指针有着不止管理数组这一个功能，我们来深入学习一下。

&nbsp;

### 指针基础操作

#### 声明一个指针

之前关于指针的声明，总感觉指针是声明数组的时候“顺便”声明的。那么，怎么样不要申请连续空间，只是单独声明一个可以保存其他地址的指针变量呢？

&nbsp;

答案就是在声明的时候，在标识符前面加上一个星号，表示这是一个指向这个类型的指针变量。

```c
int a;       //声明int类型变量，标识符为a
int b[100];  //声明int类型的数组。有一个标识符为b的，int的指针类型的(int *类型的)变量
int *p;      //声明int的指针类型的(int *类型的)变量，标识符为p
```

&nbsp;

我们常常说，平常的赋值都是将变量的值复制一份，但是指针因为是保存了地址，所以指针之间的赋值，会“让指针指向对应的地址”。

```c
int *a = ...; //a指向了某个int类型的地址，这里用...替代一下
int *b;
b=a;          //b指向了和a同一个类型的地址
```

可以通过这个动画对其了解得更加清晰一些：

<p align="center">
<img src=".\引用图片\040.gif" width="800" />
</p>

&nbsp;

例如说，我们可以让一个单独声明的指针ptr指向某一个数组声明出来的指针a，这样的话，两个指针指向了同一个地址，那么角标运算符就变成等价的东西了。

```c
int a[10];
int *ptr;
ptr=a;
a[0]=100;
ptr[1]=110;   //因为ptr现在和a指向了同一个位置，所以说这句语句等价于a[1]=110;
a[2]=120;

printf("%d",ptr[0]);   //输出结论为100

/*顺便说一句，作为随数组一起声明的指针，a无法进行任何的改变
 *例如说这里写
 	int b[20];
 	a=b;
 *会引发报错，因为如果这样做，那么你就会“搞丢”内存上原本申请的十个空间，再也无法调用到它们。
 */
```

&nbsp;

这里需要提到的一点是，之前我关于数组和指针的举例，总是使用int相关的例子，这是因为int是最为常用的变量类型。实际上需要指出的是，对于任意一个变量类型，例如说double，char，long都有其对应的数组和对应的指针变量。不要因为举例过于单一所以就忽略了它们。

```c
int a[100];
int *ptr_a;        //ptr是pointer的简写，很多时候为了程序的变量能够不言自明，可以使用ptr,pt或者p作为指针变量名字的一部分
double b[100];
double *ptr_b;
char c[100];
char *ptr_c;

ptr_a=a;
ptr_b=b;
ptr_c=c;
```

&nbsp;

需要注意的是，虽然我们简称**int的指针类型**变量为**int \*类型**，但是这并不意味者int \*是这个声明的**声明说明符** *declaration-specifiers*，如果说用逗号分割多个变量，星号只会作用在一个标识符上面。具体语法正式定义在后面统一讲。

```c
int *a,b,c;   //a是int *类型变量，b和c则是int类型的标识符。
//这个问题曾经出现在前面的练习题中

//下面这两个写法和上面两种写法等价
int c,*a,b;
int b,c,*a;
```

<p align="center">
<img src=".\引用图片\021.png" width="200" />
</p>
&nbsp;


#### 指针的解引用和地址操作符

之前的所有代码中，所有的赋值都是利用了已经存在的数组的指针。那么如果想要让指针指向一个单独的变量，需要使用一对操作符：

**地址操作符**&，也叫做引用操作符，寻址操作符。是一个一元操作符，右侧接受变量作为**操作数**，求值之后返回右侧变量对应的地址。

**解引用操作符**\*。是一个一元操作符，右侧接受指针作为**操作数**，求值之后返回右侧指针指向地址的变量。

&nbsp;

我们之前已经知道了地址操作符在scanf函数中的应用了，下面看一个案例：

```c
int a=15;
int *p;
p=&a;            //将a的地址赋值给了p，即意味着让p指向了变量a
*p=20;           //p解引用，即变量a，即将20赋值给a

printf("%d",a);  //输出为20

scanf("%d",p);   //这里p就是a的地址，因此这个函数输入的参数正确，程序会要求用户输入一个内容后，赋值给a
```

&nbsp;

需要注意一个非常易错的地方，很多初学者会将声明中的星号错误地当成解引用操作符，从而将下面这两个情况写错。

```c
int a;
int *p;
p=&a;       //声明了一个int类型变量a和一个int *类型变量p，且p指向a，这个似乎没有什么问题

int a;
int *p=&a;  //有些人可能会对这个初始化产生误解，但是这个表达和上面是一致的
//需要注意声明中，等号前面"*p"是declarator，最终标识符是"p"，而等号后面是表达式"&a"是initializer，求值是a的地址
//因此初始化最终的结论就是，一个int *类型变量p保存了a的地址，即p指向a
//具体语法正式定义在后面统一讲。
```

**解引用和地址操作符**在在结构体中有很多应用，之后在4.4中会谈及这个内容。

&nbsp;

#### 指针的基础运算操作

指针实际上还可以进行一些运算操作：指针可以进行有限的加减运算。

&nbsp;

指针可以加或者减一个常数，但是并不是改变指针指向的变量的值（如果想要这样需要使用**解引用操作符**），而是让指针指向下一个或者上一个同类型变量的地址。

```c
int a[10];
int *ptr=a;
ptr=ptr+2;

a[4]=10;
printf("%d",ptr[2]);   //输出10，因为ptr指向的是a指向地址的后两个，因此a[4]和ptr[2]表达式指的是同一个地方
```

<p align="center">
<img src=".\引用图片\041.gif" width="800" />
</p>
&nbsp;


两者指针之间可以相减，表示指针中间相差了多少个同类型的变量，指向同一个地址则相减为0。不过这种运算不是太常用。

```c
int a[10];
int *ptr=a;
ptr=ptr+2;

printf("%d",ptr-a);   //输出2
```

&nbsp;

这里有一个非常有趣的问题，都是储存计算机内存上的地址，但为什么指针的类型却有很多种？

这一点涉及到了计算机的原理了：

1. 计算机中对于不同的变量的占用空间是不一样的，因此对于同一个运算：指针加常数，在地址上产生的偏移不一致。

   <p align="center">
   <img src=".\引用图片\022.png" width="500" />
   </p>

2. 即使是存储占用空间一致，例如说float，int和unsigned int都占用四个字节，但是，对于同一个二进制含义的解读不一致，

   <p align="center">
   <img src=".\引用图片\023.png" width="600" />
   </p>

（内存中，一个地址，例如说0xA0000000这个地址，会保存1Byte也就是8Bit大小的数据，上述配图将所有的内存合并在了一起，并且都是大端书写，显得较为直观）

因此不同类型的指针实际上代表了其占用的储存空间以及对应地址的解读方式，如果说不小心搞错的话，编译器会给一个警告。

&nbsp;

另外一个点就是，使用指针就相当于"在内存上放肆狂奔"，很容易产生越界等问题，但是编译器并不会发现这个问题。出现这种问题的时候，程序会输出垃圾数据或者自我崩溃，所以要好好检查指针是否会越界。

&nbsp;

### 数组中的特殊者：字符串

char类型的数组能够放下很多个字符，在符合标准的前提下，我们称之为**字符串**。而字符串在很多编程语言中是一个特殊的东西。会有一些"特殊待遇"。

&nbsp;

#### 字符串的结构

在C语言中，规定一个**字符串**(String)是指，char类型的数组在保存的内容结束之后，在最后添加一个结束符。结束符对应ASCII表中第0位，可以直接写作数字0或者转义字符'\\0'。这个规定会在后面的一些地方起作用，主要是帮助程序检测是否已经到了字符串的末尾。只有符合这个标准的char类型数组，叫做**字符串**。

<p align="center">
<img src=".\引用图片\024.png" width="300" />
</p>
&nbsp;


在C语言中，字符串除了常规的初始化方式以外，可以通过双引号的方式初始化（回忆一下，双引号的**字面值**就是字符串），如下图

```c
int a[10]={1,2,3,4,5}
double b[10]={1.1,2.,3.21,0.4,.5}
char c[10]={'H','e','l','l','o','\0'};  //这里最后的\0就是为了符合C语言字符串的约定,也可以直接写不带单引号的0
//也可以写作
char c[10]="Hello";                     //如果这样写，最后结尾的结束符会被自动添加
```

&nbsp;

所以说，声明一个字符串的时候，需要注意多留一位给结尾符。

```c
char a[12]="Hello World!"     //有问题，没有给结尾符留空
char a[13]="Hello World!"     //正确
```

&nbsp;

#### 输入输出函数与字符串

作为"特殊待遇"之一，字符串在输入输出函数中有自己的转换说明"%s"。

&nbsp;

输出函数printf中，接受字符串(char类型数组的指针)作为"%s"转换说明的对应参数。

```c
char a[]="Thomas Yao";         //长度会被自动推导
printf("login successful.\nHello,%s\n",a);
```

&nbsp;

输入函数中，转换说明"%s"会要求用户输入一个单词，遇见空格则会停止接收，将字符串放入对应的变量中，且自动在末尾加上结尾符\0。需要注意的是，scanf的参数不需要加地址操作符，因为字符串本身是一个指针。

```c
char a[64];
scanf("%s",a);         //其他的大多数是scanf("%d",&a);之类的代码，但是字符串比较特殊
//假设用户输入"Hello"，则a中分别是'H','e','l','l','o','\0'
//假设用户输入"Hello World!"，a中仍然如上，因为空格使得scanf不再读取之后的内容。（剩下部分的具体处理机制会在下一章进行讲解）
```

&nbsp;

### 多重指针和多维数组

标识符前面加一个星号表示一个其指针类型变量，那么加两个呢？按照直觉，答案就出来了——**指针的指针类型**变量！（假设关于int，则这种变量类型就叫做**int \*\*类型**变量）

```c
int a;
int *pt1=&a;
int **pt2=&pt1;
```

他们之间就可以依次进行引用和解引用。

<p align="center">
<img src=".\引用图片\025.png" width="300" />
</p>
&nbsp;


说实话，这个**指针的指针类型**变量有一点鸡肋，有谁会给一个int类型变量套几层指针呢？

不过在一个特殊的地方会出现这种类型的变量——多维数组。

&nbsp;

多维数组的声明和使用实际上非常的直白，非常符合直觉：

```c
int a[5][4];   //声明了一个5x4的int类型二维数组
a[0][0]=15;
a[0][1]=20;
a[0][2]=3;
a[0][3]=4;
a[1][0]=6;     //一些赋值
```

&nbsp;

不过谈及到多维数组的本质，例如说二位数组，其实其就是一个"数组的数组"。例如说"int a\[3][2]"在内存上申请了长度为6个int类型的空间，并且将其分割成3个由2个int组成的数组。其中的解引用和引用的关系如下：

```c
int a[3][2];
/* 表达式     变量类型
 * a[0][0]    int
 * a[1]       int 类型的指针
 * a          int 类型的指针的指针（之后说明细节）
 */
```

<p align="center">
<img src=".\引用图片\026.png" width="400" />
</p>
&nbsp;


因此按照这个原理，声明并且初始化高维数组的时候，需要使用多重嵌套的大括号，更高维的数组同理。

```c
int a[5][4]={{1,2,3,4},{5,6,7,8}};

printf("%d\n",a[0][1]); //输出2
printf("%d\n",a[1][0]); //输出5
printf("%d\n",a[0][5]); //输出6，用法有些怪异，不应该这样使用

int b[3][3][3] =
{
    {
        {1,2,3},
        {4,5,6},
        {7,8,9},  //这个逗号可加可不加
    },
    {
        {10,11,12},
        {13,14,15},
        {16,17,18}
    },
    {
        {19,20,21},
        {22,23,24},
        {25,26,27}
    }
};                   //也许这样的排版对更高维数组而言会更好。

printf("%d\n",b[0][0][1]); //输出2
printf("%d\n",b[0][1][2]); //输出6
printf("%d\n",b[1][0][1]); //输出11
printf("%d\n",b[2][2][2]); //输出27
```

&nbsp;

### 指针和高维数组的细微区别

在上面的讲解中，我们知道了指针和数组的关联，"int a[10];int *pt;"中的a和pt同样都是**int类型的指针**，或者说是**int *类型**变量，但是从高维数组开始，例如说"int a\[5][4];int \*\*pt;"，虽然a和pt从理解上都是**int类型的指针的指针**，但是其中还是会有一些细微的差异。

&nbsp;

如果是单独的一个由连续的星号声明出来的指针变量，那么我们称之为**int \*\*（星号数可能变化)类型变量**

```c
int a;       //a是一个int 类型变量
int *pt1;    //pt1是一个int *类型变量
int **pt2;   //pt2是一个int **类型变量
int ***pt3   //pt3是一个int ***类型变量
```

&nbsp;

而声明出来的高阶数组则实际上的类型还需要随着后面数组的类型进行变化。

```c
int a;          //a是一个int 类型变量
int b[10];      //b是一个int *类型变量
int c[5][10];   //c是一个int (*)[10]类型变量，即指向了十个int类型的数组的指针的指针
int d[5][6];    //d是一个int (*)[6]类型变量，即指向了六个int类型的数组的指针的指针
int e[3][4][5]; //e是一个int (*)[4][5]类型变量，即指向了int f[4][5]这种变量的指针。
```

&nbsp;

如果说想要给高阶数组声明等价的指针，需要像下面这样声明，有些区别。

```c
int a[5][10];       // a是一个二维数组，是一个int (*)[10]类型变量
int (*pt_a)[10];    // 声明了一个int (*)[10]类型变量
pt_a=a;             // 赋值指向同一个地方，下面a和pt_a就等价了

a[2][3]=5;
printf("%d\n",pt_a[2][3]);

int b[3][4][5];     // b是一个三维数组，是一个int (*)[4][5]类型变量
int (*pt_b)[4][5];  // 声明了一个int (*)[4][5]类型变量
pt_b=b;             // 赋值指向同一个地方，下面b和pt_b就等价了

pt_b[1][3][2]=10;
printf("%d\n",b[1][3][2]);

/* 
 * 声明
 * int **pt_a;
 * int ***pt_b;
 * 然后将a和b赋值给他们，则会产生类型不符的警告。虽然他们都是两层指针，但是对于数组而言，其角标也是类型中很重要的内容
 */
```

&nbsp;

需要注意，括号是必须的，否则声明的结合顺序则会发生变化，类型就会发生变化。（这个地方语法就比较复杂了，如果你能够读懂，那是最好，如果不能，也不强求了）

```c
/*int (*pt_a)[10];结合顺序*/
int a[2][10];
int (*pt_a)[10];    // 声明了一个int (*)[10]类型变量。
pt_a=a;             // pt_a赋值等于数组a[2][10]的指针，两者相等

a[1][1]=10;
printf("%d\n",pt_a[1][1]);   //输出为10

/*int *(pt_a[10]);结合顺序*/
int a=10;
int b=20;
int c[2]={1,2};
int *pt_b[10];      // 等价于int *(pt_b[10]);
                    // 声明了十个int *类型变量，pt_b是一个指向第一个变量的指针的标识符。
pt_b[0]=&a;         // pt_b[0]赋值为指向a的指针
pt_b[1]=&b;         // pt_b[1]赋值为指向b的指针
pt_b[2]=c;          // pt_b[2]赋值等于数组c[2]的指针，两者相等

printf("%d\n",*(pt_b[0]));    //输出为10，注意因为解引用运算符比角标运算符优先度高，需要用括号改变结合顺序
printf("%d\n",*(pt_b[1]));    //输出为20
printf("%d\n",pt_b[2][1]);    //输出为2
```

&nbsp;

上面有很多及其复杂的类型关系。可以这样说，指针就是C里面最为困难抽象的内容。如果说想要研究语言细节的话，可以看4.4的正式说明，如果不想研究，也可以在面对问题的时候，按照标准的代码依葫芦画瓢。

&nbsp;

### 📄 任务4.1-关于指针的问答

请进入任务文件夹，进行一些任务问答。

&nbsp;

## 4.2 函数进阶

在之前，初次介绍输入输出函数之前，我对函数也已经有一些介绍，不过讲得并不透彻。下面的介绍会指导你写出你想要的所有函数。

&nbsp;

### 函数基础

从直觉上，函数就是一个"黑盒子"一样的东西，输入一些数据，然后函数根据输入的一个或者多个参数，返回一个函数值。

可以举出来的案例就例如说已知一个二次函数，输入x就可以得到对应的f(x)，或者说自定义一个寻找最大公约数的函数，输入两个数字x,y就会返回他们的最大公约数GCD(x,y)

<p align="center">
<img src=".\引用图片\027.png" width="700" />
</p>
&nbsp;


但是作为C语言的一部分，传递数据的时候，你当然必须要关注变量类型、参数数量之类的问题，所以你需要学习如何按照你的想法去定义一个函数。

&nbsp;

#### 定义一个函数

如果想要定义一个函数，那么要知道，函数有两个部分，一部分叫做**函数头**，另一部分叫做**函数主体**。

**函数头**依次由三部分组成：函数**返回值类型**，函数**标识符**，用括号括起来的**函数参数列表**。

**函数主体**则一定是有大括号包括起来的**复合语句块**。

<p align="center">
<img src=".\引用图片\028.png" width="400" />
</p>
&nbsp;


如果函数被**调用**了(之后会讲怎么调用)，那么程序的执行位置就会进入函数头，而函数内部是一个独立的**作用域**(之后会讲解作用域的具体原理)，这意味着所有在函数之外的变量(除了全局变量以外)全部都对函数是无效的，而函数头拥有的变量，是其他地方传入函数的参数，会成为函数可以使用的变量。

<p align="center">
<img src=".\引用图片\029.png" width="300" />
</p>
&nbsp;


函数开始向下执行，如果碰见了return语句，或者说执行到函数的结尾，那么函数会结束，程序返回到调用函数之前的位置。如果说函数的**返回值类型**为**void**，意味着函数不返回任何值；否则函数会将return语句后面的值，返回一个对应类型的值到调用函数的位置。

<p align="center">
<img src=".\引用图片\030.png" width="300" />
</p>
&nbsp;


#### 函数的调用

在另外的函数里面（例如说main函数里面），函数的调用在本质上是一个表达式。使用**函数调用操作符**，那么这个语句会调用拥有这个**标识符**的函数，并且将参数传到函数中，成为函数的一个变量。于是就发生了上面所说的函数的执行过程。并且，这个表达式求值的结论，是函数返回值的值（如果返回类型不为空的话）。

> 函数调用操作符：
>
> *function-identifier*(*parameter1*,*parameter2*,...);

&nbsp;

我们看一个案例：

```c
int adder(int a,int b){
    return a+b;
}
```

这个函数的**标识符**是adder，**参数列表**有两个int类型的值，标识符分别为a和b，**函数返回值类型**则是int。而且可以通过return语句看到，函数返回的值是参数a和b的和。

&nbsp;

那么整个程序是这样的。

```c
int adder(int a,int b){
    return a+b;
}
int main(void){
    int num1=3;
    int num2=6;
    int a=10;
    int b=20;
    
    int sum;
    sum=adder(num1,num2);   //调用函数
    
    printf("%d\n",sum);     //输出为9，因为adder函数的返回值被保存在了变量sum中
    
    return 0;
}
```

1. 在**调用函数**的语句发生时，num1和num2在括号中，作为**参数**传递到了函数中（有一些人使用的术语将这里的参数叫做**实参**）
2. 然后，程序跳转到adder函数中，adder函数就被调用了。
3. 进入adder函数之后，刚才传入的参数被命名为a和b（有一些人使用的术语将这里的参数叫做**形参**），他们依次拿到的值就是刚刚的**实参**，num1和num2。因为进入了一个独立的作用域，所以主函数中的a和b和这里的a和b完全无关。
4. 函数执行到了return语句，可以看到返回值的表达式是a+b，并且**返回值类型**是函数上写的int。
5. 这个返回值，会被作为"adder(num1,num2)"的表达式求值结论，返回并且赋值给sum，函数调用结束。

&nbsp;

现在你可以看一下之前的动画，深入理解一下函数调用的过程了。

<p align="center">
<img src=".\引用图片\037.gif" width="800" />
</p>
&nbsp;


函数的调用和返回等过程中，参数数量和类型需要严格匹配。

例如说刚刚这个程序中你不能写"sum(num1,num2,a,b);"或者"sum(num1);"，因为函数的参数列表要不多不少两个参数。你也最好不要在函数的return语句后面写上不是int类型的表达式，例如说写"return 'a';"或者写"return 1.0+a+b"(1.0+a+b这个表达式的类型是double)

如果不匹配或者犯了错，编译器在大多数情况下会警告或者报错。

&nbsp;

### 函数和递归

有了函数，那么可以是实现一种非常美妙的算法设计思路了：递归。

递归的思路就是将大问题化解成小问题，最终仅仅解决最原始的小问题，用这个方法来讲问题得到最后的解决。数学上的递推公式就是这种思想的一个代表。

&nbsp;

例如说我们想要用递归的方式来实现求阶乘。

我们知道n的阶乘的公式就是从n一直乘到1，不过从分解问题的角度，我们得到递推公式，并且知道0的阶乘就是1，那么可以用递归函数来设计阶乘运算方法：
$$
n!=n\cdot\left(n-1\right)!
$$


```c
int factorial(int n){
    if(n==0){
        return 1;
    }else{
        return n*factorial(n-1);
    }
}
```

如果求阶乘0，那么返回1，否则就用递推公式求值，再次调用函数自己，不过求的是更小的阶乘。于是不论输入什么值，都可以得到对应的值。（非负值，如果为了代码的稳定性，需要过滤意外输入负值的情况）

&nbsp;

例如说下面这个代码求阶乘5的代码，看一下它的动画，体验一下阶乘的美妙之处。

```c
int factorial(int n){
    if(n==0){
        return 1;
    }else{
        return n*factorial(n-1);
    }
}
int main(void){
	int result;
    result=factorial(5);
}
```

<p align="center">
<img src=".\引用图片\042.gif" width="800" />
</p>
&nbsp;


递归不止可以解决数学运算问题，也可以有一些其他应用。例如说一个输出n个空格的函数，也可以使用递归。

```c
void print_spaces(int n){
	if(n>=1){
		printf(" ");
		print_spaces(n-1);
	}
}
```

如果需要打印n个空格且n大于等于1，就先打印一个空格，然后再调用函数打印n-1个空格（确实有点小题大做但是也算是个递归），因为打印空格不需要任何数值的运算，所以不需要返回值，**函数返回值类型**为void。

&nbsp;

需要注意的是，递归不是实现问题的唯一手法，刚才两个案例完全可以靠for循环实现；而且，递归不一定是最为有效率的实现方法，也常常不是最节约内存的实现方法；但是递归最为美妙的优点在于代码简短，而且实现思路非常清晰，值得进行一些学习。

&nbsp;

### 📄 任务4.2-关于函数的编程

请用函数，且用递归的方式再实现一次斐波那契数列的输出。

&nbsp;

## 4.3 结构体的使用

### 结构体基础

你是否觉得C语言中变量类型过于少了一些？

或者说，现在如果要你设计一个C语言程序用来管理通讯录，你现在会的唯一方法就是：分别声明长度100的long long数组和字符串数组，然后用不同的角标来表示保存电话号码、名字以及其他内容。

你有没有一种疑惑，这个设计是不是有点过于笨拙了？

&nbsp;

没有错，结构体就是设计出来解决这种类型的问题的。结构体将一系列的基本**数据类型**绑定在一起，成为一个新的自定义的**数据类型**，使得这一系列的数据成为一个整体被统一管理。

&nbsp;

#### 定义一个结构体

首先需要做的第一步，在主函数前面，定义一个结构体里面到底有什么。

例如说我定义一个图书馆的管理系统，保存图书的相关信息。那么我们需要使用关键字**struct**来定义这个结构体，且将这个结构体的名字叫做Book。这个结构体里面保存着书名，书的价格，书的ISBN，作者名字等等信息。需要注意结构体的定义需要加分号。

```c
struct Book{
    char name[256];
    double price;
    long long ISBN;
    char author[64];
};
```

(上面只是定义一个结构体作为案例，至于究竟如何输入带空格的字符串，例如输入作者名，之后的进阶课程再进行讨论)

<p align="center">
<img src=".\引用图片\031.png" width="350" />
</p>

有些人将结构体中间绑定的变量也称作结构体的**成员**。

&nbsp;

#### 声明一个结构体变量

定义了这个结构体之后，那么现在你就拥有了一个变量类型叫做"**struct Book**"，那么你就可以像是声明int类型变量一样，声明一个自定义的结构体变量。

例如说下面这个程序在主函数中声明了50个结构体变量的数组。

```c
#include<stdio.h>
struct Book{
    char name[256];
    double price;
    long long ISBN;
    char author[64];
};

int main(void){
    int id=0;
    struct Book books[50];
}
```

需要注意的是，Book是**结构体**的**标识符**，而books是**结构体变量**的数组的标识符。

&nbsp;

#### 使用一个结构体变量

首先学习一下结构体的初始化，在大括号中要使用如下的方式初始化（book2这种方式叫做指定器*designator*，其表面的使用方法较为直观，不过语法定义较为复杂）：

```c
#include<stdio.h>
struct Book{
    char name[256];
    double price;                   //下图示意的价格为虚构
    long long ISBN;
    char author[64];
};

int main(void){
    struct Book book1={
        "Harry Potter and the Half-Blood Prince(Chinese Simplified)",
        49.99,
        9787020053230,
        "J. K. Rowling"             
    };
    
    struct Book book2={
        .ISBN=9780201896831,
        .name="The Art of Computer Programming, Vol. 1: Fundamental Algorithms, 3rd Edition",
        .price=65.00,
        .author="Knuth, Donald"            //这种用点(指定器)进行定向赋值的，可以任意交换顺序
    }
}
```

&nbsp;

如果想要在这个数组中访问一本书的数据，那么可以用**成员操作符.**来进行**成员**的直接访问，例如说下面这个代码把上面这个代码中的内容输出了。

```c
#include<stdio.h>
struct Book{
    char name[256];
    double price;                   
    long long ISBN;
    char author[64];
};

int main(void){
    struct Book book1={
        "Harry Potter and the Half-Blood Prince(Chinese Simplified)",
        49.99,
        9787020053230,
        "J. K. Rowling"             
    };
    
    struct Book book2={
        .ISBN=9780201896831,
        .name="The Art of Computer Programming, Vol. 1: Fundamental Algorithms, 3rd Edition",
        .price=65.00,
        .author="Knuth, Donald" 
	};
    
    printf("name:%s\n",book1.name);
    printf("price:%.2lf\n",book1.price);
    printf("ISBN:%lld\n",book1.ISBN);
    printf("author:%s\n",book1.author);
    printf("name:%s\n",book2.name);
    printf("price:%.2lf\n",book2.price);
    printf("ISBN:%lld\n",book2.ISBN);
    printf("author:%s\n",book2.author);
}
```

&nbsp;

需要注意一个非常重要的语法点：下面这个代码是错误的！编译器会在books和author的赋值处报错。

```c
#include<stdio.h>
struct Book{
    char name[256];
    double price;
    long long ISBN;
    char author[64];
};

int main(void){
    int id=0;
    struct Book books[50];
    books[0].name="Harry Potter and the Half-Blood Prince(Chinese Simplified)"; //报错！
    books[0].price=49.99;                
    books[0].ISBN=9787020053230;                      
    books[0].author="J. K. Rowling"; //报错！
    books[1].name="The Art of Computer Programming, Vol. 1: Fundamental Algorithms, 3rd Edition"; //报错！
    books[1].price=65.00;                
    books[1].ISBN=9780201896831;                      
    books[1].author="Knuth, Donald"; //报错！
}
```

根本问题在于，结构体的字符串和普通的字符串不大一样。结构体中如果包括字符串，则会在声明申请内存的时候，直接将对应的char变量需要的空间全部申请出来，但是"Harry Potter and the Half-Blood Prince(Chinese Simplified)"向他赋值的时候，却只能将指针赋值，这就导致了程序尝试将char *类型变量赋值到一系列的char变量中——当然会导致错误。

<p align="center">
<img src=".\引用图片\032.png" width="550" />
</p>
&nbsp;


解决方法的话，只能够通过标准库string.h中的strcpy或者memcpy进行处理，有兴趣可以查询[菜鸟教程相关信息](https://www.runoob.com/cprogramming/c-standard-library-string-h.html)。

&nbsp;

#### 和"更加进阶"的语言的联系

很遗憾的是，C语言的结构体功能就这么多了。后面很多新语言中产生了一种新的东西，叫做**类(class)**，类可以可以声明出**对象(object)**。类和结构体很相似，但是相比起只能容纳数据的**结构体**，**类**还可以自带更改自己数据的**方法(method)**，并且规定公有和私有变量，还有继承、多态、封装等等特性。

通过这些特性，编程会变得更加标准化；用接口访问操作数据，也会更加安全（数据不会被无关代码意外更改）。这种新的编程模式叫做面对对象编程。

基本上而言，较为主流的新语言，例如C++，Java，都支持这种编程思维，不过那完全是另一个话题了。

&nbsp;

### 📄 任务4.3-关于结构体的编程(挑战题)

在刚刚的案例中，已经看到了结构体管理数据的便利性了。那么下面你需要进入任务文件夹进行一个编程的任务。编程量略微有点点大，而且要用到memcpy函数，因此作为挑战题。

非常建议你在开始动手的时候先看一下范例程序是怎么运行的！

&nbsp;

## 4.4 相关的进阶话题

### typedef的使用

是不是觉得定义结构体之后却只能使用"struct Book"这种很长的字符来代表变量类型这种设计非常笨拙？那么**typedef**关键字正好就能够满足你的需求。

&nbsp;

**typedef** 的效果是，将两种类型名等价起来。这个功能使得其适合给变量类型取别名。

&nbsp;

例如说我想要把int变量类型叫做basic，那么使用下面这个代码就可以实现(虽然很无聊就是了)

```c
typedef int basic;
int main(void){
   basic a=15;
   basic b=20;
   basic c=a+b;
}
```

&nbsp;

那么同样地，我们可以将"struct Book"这种变量类型取个别名直接叫"Book"，然后之后就可以像使用"int a;"一样使用"Book a;"了。

```c
#include<stdio.h>
struct Book{
    char name[256];
    double price;                   
    long long ISBN;
    char author[64];
};

typedef struct Book Book;

int main(void){
    Book book1={
        "Harry Potter and the Half-Blood Prince(Chinese Simplified)",
        49.99,
        9787020053230,
        "J. K. Rowling"             
    };
    
    printf("name:%s\n",book1.name);
    printf("price:%.2lf\n",book1.price);
    printf("ISBN:%lld\n",book1.ISBN);
    printf("author:%s\n",book1.author);

}
```

&nbsp;

甚至还有一种非常偷懒的写法将**typedef**和结构体的定义结合在一起

```c
typedef struct Book{
    char name[256];
    double price;                   
    long long ISBN;
    char author[64];
}Book;
```

这个效果和刚才也是一样的，都可以用"Book"来代指"struct Book"。

&nbsp;

### 指针在结构体中的使用

我们还是暂时忘掉typedef带来的便捷，用完整的形式来讲解一下结构体的指针问题。

**struct**定义出了一种新的变量类型，自然，这个变量类型也就会派生出对应的指针类型。所有指针相关的内容自然也适用于这种新变量类型。

```c
struct Book{
    char name[256];
    double price;                   
    long long ISBN;
    char author[64];
};

int main(void){
    struct Book book1;      //声明了一个struct Book类型的变量，标识符为book1
    struct Book *pt_1=&book1;      //声明了一个struct Book类型的指针变量，标识符为pt_1;
}
```

&nbsp;

同样的，关于结构体的数组，也是指针组成的。

```c
struct Book{
    char name[256];
    double price;                   
    long long ISBN;
    char author[64];
};

int main(void){
    struct Book books[50];      //声明了50个struct Book类型的变量数组，指向第一个地址的标识符为books。
    struct Book *pt=books;      //声明了一个struct Book类型的指针变量，将books赋值给它，两者变得等价。
}
```

&nbsp;

结构体里面可以包含指向自己这个类型的指针。

```c
struct Book{
    char name[256];
    double price;                   
    long long ISBN;
    char author[64];
    struct Book *next;
};
```

这种组织结构常常适合组成链表。具体实现过程已经涉及到了算法，会在之后的进阶课程进行详细讲解。

&nbsp;

### 函数和结构体的定义和声明

噢，现在又来咬文嚼字了……定义**definition**和声明**declaration**的区别是什么？

&nbsp;

首先说第一个前提，那就是我们之前讲解的关于函数和结构体的内容，都是在**定义**函数或者结构体。定义函数和结构体是指，将函数和结构体的"具体功能"进行描述。

```c
int adder(int a,int b){      //定义一个函数
    return a+b;
}                           
struct Book{                 //定义一个结构体
    char name[256];
    double price;                   
    long long ISBN;
    char author[64];
};                          
```

&nbsp;

而C语言程序中，要求函数或者结构体在使用之前都必须要先**声明**。在之前的代码结构中，我们将函数或者叫结构体的**定义**写在了前面，在这种情况下，**定义**同时也是**声明**。

```c
#include<stdio.h>
int adder(int a,int b){      //调用之前先声明，定义也是一种声明
    return a+b;
}
int main(void){
    int num1=3;
    int num2=6;
    
    int sum;
    sum=adder(num1,num2);    //调用函数
    
    printf("%d\n",sum);      //输出为9，因为adder函数的返回值被保存在了变量sum中
    
    return 0;
}
```

```c
struct Book{                       //调用之前先声明，这里的定义也是一种声明
    char name[256];
    double price;                   
    long long ISBN;
    char author[64];
};
int main(void){
    struct Book book1;             //声明了一个struct Book类型的变量，标识符为book1
    struct Book *pt_1=&book1;      //声明了一个struct Book类型的指针变量，标识符为pt_1;
}

```

如果说反着写，例如说将adder函数定义在main函数之下，那么编译器会报错：没有声明函数adder。

&nbsp;

但是这个设计结构会让人有一点困惑：如果说有两个函数互相调用，或者有两个结构体互相有指针指向对方，岂不悲惨？究竟谁写在前面呢？谁在前面都会引起问题啊？

```c
void function1(void){
    function2();
}
void function2(void){
    function1();
}                         //看上去这是一个无解的问题
```

&nbsp;

于是这个时候就需要**声明**来缓解这个问题了。**声明**的意思是向编译器解释一个或者多个标识符的含义，对于函数和结构体而言，声明就像是"先开个坑"，告诉编译器有着一个东西，至于定义，可以在后面再补充上去。这样的话，就可以将定义写任意一个地方了。

对于两者，其**声明**就是去掉大括号部分，函数需要另外加上分号，而且参数列表中可以不写变量名。

```c
#include<stdio.h>
int adder(int a,int b);      //函数adder的声明，也可以不要参数的变量名int adder(int,int);
int main(void){
    int sum;
    sum=adder(10,20);        //调用函数adder
    printf("%d\n",sum);         
    return 0;
}
int adder(int a,int b){      //函数adder的定义
    return a+b;
}
```

&nbsp;

函数的**声明**，也被**函数原型**。

作为书写惯例，推荐将函数原型写在代码靠前的位置，然后再在后面的位置定义函数。

而对于结构体，除非说因为互相引用，因此需要在互相引用的前面补充一个声明，否则结构体还是直接在代码最前面写出定义为宜。

```c
#include<stdio.h>
struct Type2;                     //struct Type2的声明
struct Type1{                     //struct Type1的定义
    int data;
    struct Type2 *next;
};
struct Type2{                     //struct Type2的定义
    int data;
    struct Type1 *next;
};
int main(void){
    struct Type1 somename;        //声明一个struct Type1类型的变量
}
```

需要注意的一点是，在代码正文**声明**的是结构体类型的**变量**，和**结构体的声明**不是一个层面的概念。

&nbsp;

### 作用域和储存期

在之前的讲解中，**作用域**（scope）和**储存期**（在专业术语中还有链接这个概念）都是一个不甚明了的知识点——因为没有讲解函数，所以作用域的问题一直得不到充分地讲解。

&nbsp;

#### 作用域

第一个需要说明的是，**作用域**的研究对象是**标识符**。标识符用于指示一个**实体**，包括一个变量、一个函数、一个标签(goto跳转所需要的标签)或者其他的一些东西。

**标识符**所指代的**实体**，例如说变量，其能够被访问到的区域，我们就是这个标识符的**作用域**。任何两个实体，例如说变量或者函数，要么拥有同样的标识符但是处于不同的作用域，如果处于同一作用域则必须作用域不相同。

<p align="center">
<img src=".\引用图片\033.png" width="350" />
</p>
&nbsp;


**作用域**的真正决定因素在于其声明的位置；其真正观察方法是，判断其作用范围的终止点。如果两个标识符在同一位置结束其作用域，则说明两者作用域相同。

1. 如果说在一个**区块(block)中**声明了这个实体，则其作用域的结束位置就是对应区块的结尾。一个完整的区块包括函数(加上其参数列表)、复合语句块，C99以后包括了for语句、while语句、do while语句、if语句，以及上述提到的语句所控制的分支或者循环（即使没有大括号）。

   <p align="center">
   <img src=".\引用图片\034.png" width="650" />
   </p>

2. 如果在**所有区块外**声明了这个实体，在仅考虑单文件的情况下，则其作用域的结束位置就是整个文件的结束。

   <p align="center">
   <img src=".\引用图片\035.png" width="500" />
   </p>

3. 在区块包含的情况下（这个说法很不严谨），那么对于同一个**标识符**，作用域会被覆盖或者也叫被隐藏，即外侧区块的标识符会被同名的、内侧区块的标识符覆盖掉，暂时无法访问。这个现象持续到退出本区块。

   <p align="center">
   <img src=".\引用图片\036.png" width="500" />
   </p>

&nbsp;

例如说，跨越函数，那么就进入了一个新的区块，原本位于main函数中的所有变量就不可以被访问了。

<p align="center">
<img src=".\引用图片\037.gif" width="800" />
</p>
&nbsp;


而之前的一个案例就展示了区块的遮盖现象，新的区块中同名的标识符使得外侧的同名变量无法访问。

<p align="center">
<img src=".\引用图片\038.gif" width="800" />
</p>
&nbsp;


声明一个**全局变量**则使得其能够被所有地方的函数访问。

但是从编程技巧上、建议除非必须(例如说一个需要被各处使用的参照数据表)，不要使用全局变量。

&nbsp;

#### 储存期

**储存期**是指，变量中的数据会被保存多久。

对于常规声明的变量而言，**储存期**为**自动**，变量的有效性持续到退出区块，然后这个变量的内存空间就可以被挪作他用。你可以看一看上面的adder函数的案例（向上数第二个gif），在退出函数的同时，变量a和b立马被销毁，之后再也没有机会访问到他。

&nbsp;

如果说在声明的过程中，使用了**static**储存类别限定符，那么这个**储存期**则会变成**静态**，这意味着即使是退出了区块，变量也不会被销毁，因为其有可能会被再次访问到。

例如说下面这个案例中，函数中声明了一个静态的变量counter，其可以记录函数被调用的次数。第一次执行本函数的时候，初始化生效，变量赋值为0，之后每一次调用，则会使得这个**静态**变量增加一。即使是离开了作用域，这个变量虽然不能被访问，但是没有被销毁。

```c
#include<stdio.h>
void input_is_1(void);
int main(void){
    int input;
    while(1){
        scanf("%d",&input);
        if(input==1){
            input_is_1();
        }
    }
}
void input_is_1(void){
    static int counter=0;
    counter++;
    printf("This is the %d time(s) to call this function.\n",counter);
}
```

&nbsp;

有了这两个知识点，你就明白取名什么时候会引起冲突，什么时候不会引起冲突了。而且**static**关键字也为整个程序提供了更加强大的功能。

&nbsp;

另外再介绍一个同样是出现在这个位置的关键字 **const**，虽然它和作用域与储存期无关，但是它也有自己的作用。**const**关键字修饰的变量必须一开始就初始化，且初始化之后就不能再进行变动。这一点用于保存或者限定一些不需要进行变动的参照数据，例如下面的代码：

```c
#include<stdio.h>
int main(void){
    int input;
    const double PI=3.1415;     //这个PI之后无法被更改，而且正好也不需要更改它
    printf("Radius:");
    scanf("%d",&input);
    printf("Area size:%lf\n",PI*input*input);
}
```

&nbsp;

### 指针当作函数参数

指针当作函数参数——是C语言的一个难点，也是熟练运用C语言之后一个基础操作。

&nbsp;

首先说一下一些必须要用指针当作函数参数的操作。例如说看下面这个swap函数——我们希望使用这个函数交换两个变量的值，但是很遗憾的是，做不到！

```c
//这是一个失败的程序
#include<stdio.h>
void swap(int num1,int num2);
int main(void){
    int a=5;
    int b=10;
    printf("Before swap:%d and %d\n",a,b);
    swap(a,b);
    printf("After swap:%d and %d\n",a,b);
}
void swap(int num1,int num2){
    int temp=num1;
    num1=num2;
    num2=temp;
}
```

可以通过刚刚学到的作用域的思想看一看，实际上参数虽然传进去了，但是你交换了一个寂寞——不论在swap函数中进行什么操作，你操作到的都是原来数字的一个复制品，真正想要交换的变量则在作用域外，完全没法弄到手。

&nbsp;

这个时候有一个奇招，可以让程序隔着作用域也能间接把main函数中的两个代码也访问到。

具体的方法就是将a和b的指针传进去。毕竟指针指向的地址是恒定的，再配合解引用操作符，不就可以将原本不能访问到的变量拿到手了吗？

```c
#include<stdio.h>
void swap(int *num1,int *num2);
int main(void){
    int a=5;
    int b=10;
    printf("Before swap:%d and %d\n",a,b);
    swap(&a,&b);
    printf("After swap:%d and %d\n",a,b);
}
void swap(int *num1,int *num2){
    int temp=*num1;
    *num1=*num2;
    *num2=temp;
}
```

&nbsp;

利用同样的思路，可以将管理数组的指针传进去，这样的话在函数中就可以访问这个数组了。

```c
#include<stdio.h>
int sum(int *num,int length);
int main(void){
    int a[10]={1,2,3,4,5,6,7};
    int result=sum(a,7);
    printf("%d",result);
}
int sum(int *num,int length){
    int temp=0;
    for(int i=0;i<=length;i++){
        temp+=num[i];
    }
    return temp;
}
```

&nbsp;

需要注意高维数组需要写对变量类型。如果不太好写，可以直接将声明时的那一句话抄到参数列表中，也没有问题。

```c
#include<stdio.h>
int det(int matrix[2][2]);           //类型名也可以写作int (*matrix)[2]
int main(void){
    int m[2][2]={{1,2},{3,4}};
    printf("%d",det(m));
}
int det(int matrix[2][2]){
    return matrix[0][0]*matrix[1][1]-matrix[1][0]*matrix[0][1];
}
```

&nbsp;

对于结构体，如果结构体要进函数，也推荐通过传递指针的方式来解决——毕竟一个指针比一个结构体本身要小得多。

```c
#include<stdio.h>
struct Book{
    char name[256];
    double price;
    long long ISBN;
    char author[64];
};
void print_info(struct Book *target);

int main(void){
    struct Book book1={
        "Harry Potter and the Half-Blood Prince(Chinese Simplified)",
        49.99,
        9787020053230,
        "J. K. Rowling"             
    };
    print_info(&book1);
}
void print_info(struct Book *target){
    printf("name:%s\n",(*target).name);
    printf("price:%.2lf\n",(*target).price);
    printf("ISBN:%lld\n",target->ISBN);
    printf("author:%s\n",target->author);
}
```

因为结构体的指针太常用了，而写"(*target).price"略显笨拙，因此有一个**箭头运算符**，可以代替这个写法：**箭头运算符**首先解引用这个结构体，然后自动访问其对应名字的成员。

&nbsp;

### 动态管理内存

下面这个问题则是让你的C语言程序变得强大的关键因素了。

你是不是在之前的编程中发现C语言数组非常糟糕——必须要声明的时候限定大小。岂不是我设计的软件永远都有一个上限？（在忽略VLA的情况下）

这个时候，动态管理内存的一对函数：malloc()和free()就出场了。使用这个库的时候，需要引入stdlib.h。

&nbsp;

malloc函数接受一个整数作为参数，表明要申请的空间大小，以Byte为单位。其返回值是一个指针，这个指针指向了这段空间的第一个位置。

假设说我要申请一个4Byte大小的空间，这个空间正好用来放一个int类型的数字，于是用int类型指针来接受返回值。

```c
int *pt=malloc(4);
```

&nbsp;

当然，既然是声明类型，建议配合使用sizeof乘以所需变量个数，用于使代码更加清晰。

另外，malloc返回值的指针类型是void *类型，即void类型的指针。之所以这样，是因为不知道这个空间究竟会被用来存储什么类型的变量，因此直接用void *作为一种通用的解决方案。虽然不必要，但是建议在返回值前面添加显式的类型转换（int *）来表达出变量类型。

```c
int *a=(int *)malloc(4*sizeof(int));
```

&nbsp;

这样的话，你就可以实现之前无法实现的梦想：申请一个以变量决定长度的数组了：

```c
#include<stdio.h>
#include<stdlib.h>
int main(void){
    int size;
    scanf("%d",&size);
    int *num=(int *)malloc(size*sizeof(int));   //写int num[size];则有问题
    //然后你就可以使用num数组了
}
```

malloc甚至可以申请你自己定义的结构体变量，只要你使用对应的指针和对应的sizeof即可。

&nbsp;

需要注意的是，如果你认为这个数组不再需要了，请使用free，其接受一个指针类型的参数。free函数会将这一段空间拿去回收，避免程序占用过多内存。

```c
int *num=(int *)malloc(10*sizeof(int));  //申请
free(num);                               //回收
```

&nbsp;

（实际上现在很多的推荐中都不建议使用malloc了，不过作为理解C语言底层的一个函数，也应该学一学。）

&nbsp;

### 语法正式定义

终于到了激动人心的时刻：这一次是最后一次讲解语法，但是这一次讲解将会尝试将所有讲过的语法现象用正式的形式来进行说明。

需要注意的是，这里的标准主要参照C99，纳入了*block-item-list*，*clause-1*等等；但是部分参照早先标准，对部分语法进行了略微的简化或者忽略，例如没有讲解*designator*，*union*，例如忽略了匿名声明器语法、忽略掉了旧式参数列表，忽略了预处理器等等。

之所以这样做，是为了和我已经讲到的内容进行贴合，过滤掉一些过于困难且不需要、或者过于古旧的东西，但是又引入了一些适应新时代的东西。如果你对这个有兴趣，可以到谷歌上搜索"ISO C 1999"或者直接更新的标准，应该会找到一份大约500多页的PDF，那就是"C的圣经"了。

&nbsp;

#### 标识和用语提示

1. 如果使用了*斜体*，代表这是一个语法成分，语法成分都会被进行更加细致的，向下拆分的定义。

2. 如果使用了**粗体**，则说明这是一个不可拆分的内容了，也就是说其会出现在程序中。

3. 作为语法成分的定义，本文会使用如下的模板进行标识，这种定义具有高度的递归特征。

   > *grammar-components1*:<br>
   > 	*example1* *example3*<br>
   > 	*example2*<br>
   > 	**example3**

   这意味着，我对*grammar-components1*这个语法成分进行了定义。

   下面定义中，除非另有说明，每一行代表一种*grammar-components1*可能的定义，例如本文中*grammar-components1*既可以是*example1* *example3*，即两者的依次组合；也可以是*example2*，也可能是**example3**，而且**example3**不可以再拆分，就是会出现在代码中的文字。

   第一行的冒号并不参与到语法的定义中，仅仅为了排版美观。

4. <sub>OPT</sub>角标代表这个成分可选，可有也可以没有。

&nbsp;

#### 翻译单元

讲解翻译单元 *translation-unit* 这个概念之前，我们再细致地讲解一下C语言具体是怎么将你的源代码.c文件编译成.exe可执行文件的。

<p align="center">
<img src=".\引用图片\002.png" width="500" />
<p align="center">我们之前的认识大概是这样的，汇编语言和机器写的是MMIX，并非常规CPU使用的指令集</p>
</p>
&nbsp;


下面介绍中的粗体仅仅做关键词的标注。

一个整个的c源代码文件，例如"Hello World.c"，从更高的角度来看，由两个部分所组成，井号开头的都属于**预处理器**相关的内容，例如"#include<stdio.h>"。剩下的代码则是你敲出来的实现功能的代码。



<p align="center">
<img src=".\引用图片\003.png" width="500" />
</p>

第一步就是预处理，"Hello World.c"会经过**预处理器**，变成"Hello World.i"。

**预处理器**其实际作用就是将stdio.h这个头文件中的所有代码复制粘贴到了这里，并且替换掉了这一行（stdio.h存在于你系统的某处，对于我们而言，就是被Dev-Cpp好好地管理在某处）。而stdio.h中的会出现的东西无非就是函数原型(例如说用到的printf函数的原型就在里面)，以及另外一些预处理器相关的代码。

&nbsp;

<p align="center">
<img src=".\引用图片\004.png" width="500" />
</p>
第二部分就是编译，"Hello World.i"会经过**编译器**，变成"Hello World.o"。

**编译器**中，代码一步一步变成**汇编代码**然后**机器代码**（更加详细地说，是编译器和汇编器分别负责了这两步），但是.o的机器代码不够完整，仍然需要进一步加工才能够运行。

&nbsp;

<p align="center">
<img src=".\引用图片\005.png" width="500" />
</p>

第三部分是链接，"Hello World.o"会经过**链接器**，最终变成"Hello World.exe"

**链接器**中，所有的.o文件会被连在一起，（对于现在而言，只有一个，所以这一步就没做啥）。同时**链接器**会去找一些系统中提供的C动态链接库文件，例如Windows系统下就是去寻找dll文件。

因为stdio.h中都是一些函数的**声明**，函数的声明（而非定义）就只有一个函数头，其具体实现则由系统负责，因此**链接器**最终会去找系统拿到具体实现后将他们拼接，变成独立的exe可执行文件。

&nbsp;

<p align="center">
<img src=".\引用图片\006.png" width="800" />
</p>

而在这个过程中，每一个经过了**编译器**之后的.o文件，就叫一个翻译单元 *translation unit*。实际上所谓的全局作用域，即**所有区块外**声明时出现的标识符，其作用域是一个翻译单元，不过因为目前讨论的是单文件编译，所以作用域约等于本文件结尾。

&nbsp;

从上面这个过程来看，在忽略预处理器指令的情况下，不严谨地说，我们可以将**你写的一个C文件，在语法成份上看作一个翻译单元 *translation-unit***。而我们就以一个翻译单元作为根基，研究整个语法定义。

<p align="center">
<img src=".\引用图片\007.png" width="400" />
</p>
&nbsp;


一个翻译单元 *translation-unit* ，由多个外部声明 *external-declaration* 组成（为什么是这个名字则暂时不用关心），而一个*external-declaration* 则既可以是一个声明 *declaration* 或者一个函数定义 *function-definition*


> *translation-unit*:<br>
> 	*external-declaration*<br>
> 	*translation-unit* *external-declaration*<br>
>
> *external-declaration*:<br>
> 	*function-definition*<br>
> 	*declaration*<br>

&nbsp;

#### 标识符*identifier*

*identifier* 标识符，用于指示一种实体，这个实体可以是一个变量、一个函数、一个标签、一种 **typedef** 所指的类型或者是其他的东西。代码中用标识符来为这些实体提供了类似于名字的功能。

&nbsp;

标识符接受数字和大小写字母和下划线\_组成一个无空格的单词，但是其第一位不能是数字，因此其定义如下。

> *identifier*:<br>
> 	*nondigit*<br>
> 	*identifier* *nondigit*<br>
> 	*identifier* *digit*<br>
> *nondigit*: one of<br>
> 	**\_ a b c d e f g h i j k l m**<br>
> 	**n o p q r s t u v w x y z**<br>
> 	**A B C D E F G H I J K L M**<br>
> 	**N O P Q R S T U V W X Y Z**<br>
> *digit*: one of<br>
> 	**0 1 2 3 4 5 6 7 8 9**<br>

&nbsp;


非常不推荐使用下划线作为标识符的开头，其原因参考刚才讲解的翻译单元中所讲：实际上的最大的作用域是翻译单元，而只要你用了#include，标准库头文件会被包含到你的翻译单元中，这些头文件中的标识符使用下划线开头。为了避免可能的冲突，请不要用下划线作为你自己的标识符的开头。

&nbsp;

#### 声明

声明是向编译器一个或者多个标识符的含义。其可以声明一个变量，也可以是一个结构体，也可以是一个函数，甚至可以是**typedef**。这些都是声明的一个部分。定义 definition 也是声明的一种，只不过它特指包含了函数体的函数声明（否则仅仅算函数原型）以及说明了结构体具体所需空间的结构体声明。

&nbsp;

声明 *declaration* 前面一部分是 *declaration-specifiers* ，后面一部分是可选的 *init-declarator-list*，然后用分号结尾。

<p align="center">
<img src=".\引用图片\009.png" width="700" />
</p>

> *declaration*:<br>
> 	*declaration-specifiers*  *init-declarator-list*<sub>OPT</sub> **;**

&nbsp;

##### 声明的前半段 1：*declaration-specifiers* 声明说明符

*declaration-specifiers* 由有限个 *storage-class-specifier* ，*type-specifier*，*type-qualifier* 组成。

<p align="center">
<img src=".\引用图片\010.png" width="700" />
</p>

> *declaration-specifiers*:<br>
> 	*storage-class-specifier* *declaration-specifiers*<sub>OPT</sub><br>
> 	*type-specifier* *declaration-specifiers*<sub>OPT</sub><br>
> 	*type-qualifier* *declaration-specifiers*<sub>OPT</sub><br>

&nbsp;

*storage-class-specifier* 储存类别说明符，由如下的几种关键字组成，我们目前了解 **typedef** 和 **static**

> *storage-class-specifier*:<br>
> 	**typedef**<br>
> 	**static**<br>
> 	**extern**(未讲解)<br>
> 	**auto**(未讲解)<br>
> 	**register**(未讲解)<br>

&nbsp;

*type-qualifier* 类型限定符，由如下的集中关键字组成，我们目前了解 **const**

> *type-qualifier*:<br>
> 	**const**<br>
> 	**restrict**(未讲解)<br>
> 	**volatile**(未讲解)<br>

&nbsp;

*type-specifier* 类型说明符，由如下的集中关键字组成，前面的关键字我们一开始已经学习过了，后面的 *struct-specifier* 和 *typedef-name* 我们也已经会使用了。

> *type-specifier*:<br>
> 	**void**<br>
> 	**char**<br>
> 	**short**<br>
> 	**int**<br>
> 	**long**<br>
> 	**float**<br>
> 	**double**<br>
> 	**signed**<br>
> 	**unsigned**<br>
> 	*struct-specifier*<br>
> 	*typedef-name*<br>

(*struct-specifier*在原文是*struct-or-union-specifier*，但是我们没有讲解过union的使用)

&nbsp;

*typedef-name* 用于定义 **typedef** 目标的名字，因此就是一个*identifier*

<p align="center">
<img src=".\引用图片\011.png" width="700" />
</p>
&nbsp;

> *typedef-name*:<br>
> 	*identifier*

&nbsp;

##### 声明的前半段 2：*struct-specifier* 结构体说明符 

上述定义中，*type-specifier*中的 *struct-specifier* 较为复杂而且相对独立，因此做单独讲解。

&nbsp;

*struct-specifier* 结构体说明符是由下面两种形式进行声明的。第一种用于定义结构体或者声明结构体变量时用，第二种用于声明结构体或者声明一个结构体类型的变量。

<p align="center">
<img src=".\引用图片\012.png" width="700" />
</p>

> *struct-specifier*:<br>
> 	**struct** *identifier*<sub>OPT</sub> **{** *struct-declaration-list* **}**<br>
> 	**struct** *identifier*<br>

&nbsp;

*struct-declaration-list* 结构体声明列表，即用于说明结构体内部拥有什么类型的变量，其由多个*struct-declaration*组成。而*struct-declaration* 结构体声明中，其前面是*specifier-qualifier-list*，后面是*declarator-list*。

> *struct-declaration-list*:<br>
> 	*struct-declaration*<br>
> 	*struct-declaration-list* *struct-declaration*<br>
>
> *struct-declaration*:<br>
> 	*specifier-qualifier-list* *declarator-list* **;**<br>

(原文中*declarator-list*是*struct-declarator-list*，但是其涉及的bit-field用法不做讲解，因此直接降级为*declarator-list*)

&nbsp;

顾名思义，*specifier-qualifier-list* 是由多个 *type-qualifier* 或者 *type-specifier* 组成，而 *declarator-list* 是由多个 *declarator* 组成。（实际上这意味着书写结构体中的变量时，不能出现*storage-class-specifier*）这意味着，即结构体中单条声明的语句和普通的声明几乎一致，只不过无法在前半部分使用 *storage-class-specifier* ，且无法初始化。

<p align="center">
<img src=".\引用图片\013.png" width="700" />
</p>

> *specifier-qualifier-list*:<br>
> 	type-specifier specifier-qualifier-list<sub>OPT</sub><br>
> 	type-qualifier specifier-qualifier-list<sub>OPT</sub><br>
> *declarator-list*:<br>
> 	*declarator*<br>
> 	*declarator-list* *declarator*<br>

而 *declarator* 声明器会在后面声明的后半段 3 讲解。

&nbsp;

##### 声明的后半段 1：*init-declarator-list* 初始声明符列表 至 声明器 *declarator* 和初始化器 *initializer*

*init-declarator-list*是由多个*init-declarator*用逗号分割开来组成的。

<p align="center">
<img src=".\引用图片\014.png" width="400" />
</p>

> *init-declarator-list*:<br>
> 	*init-declarator*<br>
> 	*init-declarator-list* **,** *init-declarator*<br>

&nbsp;

*init-declarator*分为两种，一种是直接的declarator，另外一个是*declarator**=**initializer*的形式。

<p align="center">
<img src=".\引用图片\016.png" width="600" />
</p>

> *init-declarator*:<br>
> 	*declarator*<br>
> 	*declarator* **=** *initializer*<br>

&nbsp;

##### 声明的后半段 2：初始化器 *initializer*

*initializer*可以有两种形式，一种是直接的**表达式** *expression*，也可以是由大括号括起来的 *initializer-list* 组成， *initializer-list* 最后多一个逗号也无妨。而*initializer-list*是由若干由逗号分割开的 *initializer* 组成的。使用这种 *initializer-list* 的层层组合，可以给任意维度的数组进行依次的赋值。

<p align="center">
<img src=".\引用图片\017.png" width="300" />
</p>
> *initializer*:<br>
> 	*expression*<br>
> 	**{** *initializer-list* **}**<br>
> 	**{** *initializer-list* **, }**
> 
> *initializer-list*:<br>
> 	*initializer*<br>
> 	*initializer-list* **,** *initializer*

这里主要参照的不是C99而是更早的标准。C99中的 *designator* 的使用很符合直觉但其定义并不简单，故不作细致讲解。

&nbsp;

##### 声明的后半段 3：声明器 *declarator*

*declarator* 声明器是是依次由可选的 *pointer* 指针 和 *direct-declarator* 直接声明器 组成。这个 *pointer* 是一种语法成分。

<p align="center">
<img src=".\引用图片\018.png" width="600" />
</p>

> *declarator*:<br>
> 	*pointer*<sub>OPT</sub> *direct-declarator*

&nbsp;

*pointer* 指针可以由若干个星号 **\*** 组成，每一个星号后面可以跟着可选的 *type-qualifier-list*。而 *type-qualifier-list* 则是由若干个 *type-qualifier* 组成。

> *pointer*:<br>
> 	**\*** *type-qualifier-list*<sub>OPT</sub><br>
> 	**\*** *type-qualifier-list*<sub>OPT</sub> *pointer*
>
> *type-qualifier-list*:<br>
> 	*type-qualifier*<br>
> 	*type-qualifier-list* *type-qualifier*

这里的 *type-qualifier-list* 主要负责的是一个很罕见的情况：常值类型的指针。因为如果你声明"const int *a"，则这是一个指向了"const int"类型的指针，即指向的变量是常值，但指针本身的指向则可以被更改。如果说想要申请一个一经初始化就不可变化的指针，则应该声明"int *const a"，而这就是这个语法点的用途。

```C
#include<stdio.h>
int main(void){       //这段代码可以通过，pt本身可以被更改
	const int a=15;
	const int b=20;
	const int *pt=&a;
	pt=&b;
	printf("%d\n",*pt);
} 

#include<stdio.h>
int main(void){
	int a=15;
	int b=20;
	int *const pt=&a;
	//pt=&b;                //这一行代码会引起错误，因为pt是一个常值指针。
	printf("%d\n",*pt);
} 
```

&nbsp;

而 *direct-declarator* (即去掉前面 *pointer* 的 *declarator* )有如下的很多种定义

<p align="center">
<img src=".\引用图片\019.png" width="500" />
</p>

1. 一个光杆的 *identifier*

2. 一个用括号包裹起来的 *declarator* ，这个存在的意义主要是改变结合顺序以确定实际变量类型，范例如下。

   ```c
   int *pt_1[3];         //这个变量类型，是一个指向长度为3的数组的指针，即pt_1的变量类型为int (*)[3]
   int (*pt_2)[3];       //这个变量类型，是一个int *类型长度为3数组，即pt_2[0],pt_2[1],pt_2[2]三者变量类型为int *
   
   //具体观察变量类型的方法是，按照语法分析规律从内向外观察，这一点就不做过多要求了
   ```

3. 一个 *direct-declarator* 后面跟上有中括号的常值表达式，常值表达式则是可选的，这个主要用于声明数组。

4. 一个 *direct-declarator* 后面跟上用括号括起来的 *parameter-type-list* 参数类型列表，这个主要用于声明函数原型。


> *direct-declarator*:<br>
> 	*identifier*<br>
> 	**(** *declarator* **)**<br>
> 	*direct-declarator* **[** *constant-expression*<sub>OPT</sub> **]**<br>
> 	*direct-declarator* **(** *parameter-type-list* **)**

这里主要参照的不是C99而是更早的标准，忽略了变长数组VLA以及相关概念，因为变长数组的引入对于C语言的数组本质引起了一些变化。

&nbsp;

函数原型中的 *parameter-type-list* 参数类型列表 可以直接是 *parameter-list* 参数列表，也可以在*parameter-list*后面添加 **, ...** 表示不定参。相关内容暂时不做讲解，我们目前写的函数全都是固定参数个数的函数。

而 *parameter-list* 则是由多个用逗号分割开的 *parameter-declaration* 函数声明 组成。

而 *parameter-declaration* 则是由 *declaration-specifiers* 声明说明符 和 *declarator* 声明器 组成。这两者的定义在之前已经说明过了。

而这意味着参数列表里面，可以用逗号分割着像是普通的声明一样书写变量。只不过参数列表的变量中只能一个一个声明，而且都不能初始化。

> *parameter-type-list*:<br>
> 	*parameter-list*<br>
> 	*parameter-list* **, ...**
>
> *parameter-list*:<br>
> 	*parameter-declaration*<br>
> 	*parameter-list* **,** *parameter-declaration*
>
> *parameter-declaration*:<br>
> 	*declaration-specifiers* *declarator*

&nbsp;

#### 函数定义

上面的内容中，我们仅仅讨论了翻译单元 *translation-unit* 的其中一种可能性：声明 declaration。另外一种可能性，*function-definition* 函数定义，则相对简单。*function-definition* 依次由 *declaration-specifiers* ，*declarator* 还有 *compound-statement* 组成。其中前两者组成成分已经在声明中进行了讲解，而后者 *compound-statement* 会在之后的语句中讲解。

<p align="center">
<img src=".\引用图片\020.png" width="350" />
</p>

> *function-definition*:<br>
> 	*declaration-specifiers* *declarator* *compound-statement*

这里忽略掉了旧式函数定义的写法。

&nbsp;

#### 语句

语句是C语言中实现功能的基本单元，我们之前已经挨着学过了六种语句并且进行了详细解析，因此这里就仅仅进行罗列了。

statement 语句分为六种，而每一种有自己的几种定义：

> statement:<br>
> 	labeled-statement<br>
> 	compound-statement<br>
> 	expression-statement<br>
> 	selection-statement<br>
> 	iteration-statement<br>
> 	jump-statement
>
> <br>
>
> *labeled-statement*:<br>
> 	*identifier* **:** *statement*<br>
> 	**case** *constant-expression* **:** *statement*<br>
> 	**default** **:** *statement* 
> 
> <br>
>
>  *compound-statement:*<br>
> 	**{** *block-item-list*<sub>OPT</sub>**}**
>
> *block-item-list*：<br>
> 	*block-item*<br>
> 	*block-item* *block-item-list*
>
> *block-item*:<br>
> 	*declaration* <br>
> 	*statement*
>
> <br>
>
> *expression-statement*:<br>
> 	*expression*<sub>OPT</sub> **;**
>
> <br>
>
> *selection-statement*:<br>
> 	**if (** *expression* **)** *statement*<br>
> 	**if (** *expression* **)** *statement* **else** *statement*<br>
> 	**switch (** *expression* **)** *statement*
>
> <br>
>
> *iteration-statement*:<br>
> 	**while (**  *expression*  **)**  *statement*<br>
> 	**do** statement **while (** expression **) ;**<br>
> 	**for (** expression<sub>OPT</sub> **;** expression<sub>OPT</sub> **;** expression<sub>OPT</sub> **)** statement
>
> <br>
>
> *jump-statement*:<br>
> 	**goto** *identifier* **;** <br>
> 	**continue** **;**<br>
> 	**break** **;**<br>
> 	**return** *expression*<sub>OPT</sub>

&nbsp;

至此我们学过的所有语法现象都集合在了这上面的定义中。

当然，这里面有少量的语法成分没有展开： *expression* 和 *constant-expression* 。这两者，我们对其也已经有了很多的认识，我们知道表达式由操作数和操作符组成，而常值表达式意味着表达式里面不含任何变量。至于具体细节，这里就不展开了——否则还可以写很多很多！

&nbsp;

### 📄 任务4.4-关于指针的编程

请完成任务文件夹中关于指针的编程练习。

&nbsp;

## 4.5 编程练习

这一次的编程练习很多😂，不用害怕，因为你现在学习的内容已经非常完备了。只是说在实践中，你能否拥有很好的思路，以及是否熟练而已。而这些编程练习就是辅助你进行一些工作，让你对计算机有更多的理解。

&nbsp;

另外，可以到**附录3**中去寻找**语法参考**，可以到**附录4**中去寻找**代码纠错建议**。

&nbsp;

### 4.5.1-字符串长度输出

首先程序输入一个单词，你需要将这个没有空格的单词保存到一个字符串中，然后你需要输出这个单词的实际长度，不计算结尾符。

测试的单词最长为32位(含结尾符)

|       | 输入        | 输出 |
| ----- | ----------- | ---- |
| 案例1 | 123111      | 6    |
| 案例2 | Apple-pie   | 9    |
| 案例3 | asdfg123::: | 11   |

&nbsp;

### 4.5.2-回文检测器

回文即一个字符串以及其反向的字符串是一致的。例如说1234321是回文，但是asdw就不是。

首先程序输入一个没有空格的字符串，然后你需要检测它是不是回文。是则输出yes，否则输出no

测试单词最长为32位(含结尾符)

|       | 输入    | 输出 |
| ----- | ------- | ---- |
| 案例1 | 1212333 | no   |
| 案例2 | asdsa   | yes  |
| 案例3 | zzzz    | yes  |

提示：你可以将你4.5.1的代码封装成函数用在此题上。

&nbsp;

### 4.5.3-投票统计(NOIP 2014普及组)

在社交媒体上，经常会看到针对某一个观点同意与否的民意调查以及结果。例如，对某一观点表示支持的有 1498 人，反对的有 902  人，那么赞同与反对的比例可以简单的记为1498:902。不过这个比例的数值太大，难以一眼看出它们的关系。对于上面这个例子，如果把比例记为 5:3，虽然与真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时也显得比较直观。

现给出支持人数 A，反对人数 B，以及一个上限  L，请你将 A 比 B 化简为 A’ 比 B’ ，要求在 A’ 和 B’ 均不大于 L 且 A’和 B’互质(两个整数的最大公约数是1)的前提下， A’ / B’  ≥  A / B ，且  A’ / B’ - A / B 的值尽可能小。

【输入】输入共一行，包含三个整数  A，B，L，每两个整数之间用一个空格隔开，分别表示支持人数、反对人数以及上限。

【输出】输出共一行,包含两个整数  A’，B’，中间用一个空格隔开，表示化简后的比例。

对于 100%的数据，1 ≤ A ≤ 1,000,000，1 ≤ B ≤ 1,000,000，1 ≤ L ≤ 100，A/B ≤ L。

|       | 输入        | 输出 |
| ----- | ----------- | ---- |
| 案例1 | 1498 902 10 | 5 3  |

&nbsp;

### 4.5.4-有缓存的斐波那契数列

在之前的递归法求斐波那契数列的程序中，你有没有测试过稍微大一点的值呢？输入40需要等待接近一秒，而输入50则会让程序陷入几十秒的运算，输入60则需要等待时长非常久！如果你测试过，就会发现随着求项数越大，其所消耗掉的时间会越来越长，而且高于线性关系。这个原因自然也不言而喻：递归所消耗的运算太多了。

如果你想要知道fib[5]，则需要分别计算fib[4]，fib[3]

为了计算fib[4]，fib[3]，则需要分别计算fib[3]，fib[2]，fib[2]，fib[1]

...

你会发现需要计算的量是呈现树状增长的，因此程序会不堪重负，不断递归运算结论。

不过看到了问题所在，解决方法也就呼之欲出了：在递归的过程中，有大量的值被重复运算，如果说能够把重复运算的值保存下来，不就终止了这种树状结构的发展吗？

&nbsp;

你需要做的任务，是用动态内存的方法，缓存已经运算过的值，如果在递归调用的时候，值已经被运算了，那么直接取用此值，不必再递归运算。

测试值会适当取大一些（不会超过long long的容纳范围），并且测试程序也会按照惯例值来收紧测试时间，超时自动错误。当然，每一台电脑的性能不同，测试程序卡时间的做法不一定有效(也有可能误伤)，请你一定要实现递归缓存（而不是动态内存申请数组后，从1开始挨着向后运算）。

&nbsp;

### 4.5.5-牛顿求根法

[牛顿求根法](https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95)的用处是通过迭代的算法，逼近出某一个函数的某一个零点。首先假设一个初始点x0，然后以初始点开始带入如下的一个迭代方程，来不断更新此点：
$$
x_{n+1}=x_n-\frac{f(x_n)}{f\prime(x_n)}
$$

在理想的情况下，牛顿求根法的迭代会不断逼近一个零点，更多的数学原理请参照维基百科。你现在的任务是实现一元五次方程的牛顿求根法程序。

&nbsp;

现在输入七个整数，分别是五次方程的六个系数a,b,c,d,e,f，第七个输入是牛顿求根法迭代的初始位置：
$$
ax^5+bx^4+cx^3+dx^2+ex+f=0
$$


请你实现牛顿求根法的代码，请在迭代差距小于0.00001的时候停下来，并且输出三位小数的结论。

注意：在一些特定情况下，不当的初始点会引起过程不收敛。但是测试程序中所有的数据都保证不会引起过程不收敛，你不需要检查这个问题。

&nbsp;

|       | 输入             | 输出   |
| ----- | ---------------- | ------ |
| 案例1 | 5 3 1 11 5 3 -2  | -1.387 |
| 案例2 | -1 4 9 -3 3 1 -2 | -1.906 |

&nbsp;

## 4.6 基础篇的完结

### 完结寄语

基础篇完结了！如果说你能够走到这里，那么我对你的毅力表示赞赏。恭喜！现在的你，如果能够掌握上面所说的大多数内容，能够对C语言的各种基础功能掌握得差不多了。

即使你对语言本身掌握得不够熟练，也许每次编程前都需要看一看之前的代码才能回忆得起一些东西的用法，但是那些精确到行的程序模型，以及对各种细节概念讲解，至少能够让你每次遇到问题的时候，经过自己的检查，能找到对应的原因和解决方案。

&nbsp;

正如一开始所说，本教程的目的，是带领零基础读者度过编程语言初学的最困难的时期——在这个时期中，你对计算机基础一无所知，很多现象无法得到充分解释，对C语言本身也一无所知，一写代码就立马被编译器的几十条错误和警告打得头破血流😂。拿起很多经典教材其实读得半懂不懂，拿起代码也写得磕磕绊绊，因此很快就自信心全无，快速弃坑。

因此我花了两章半都在讲解基础知识——到第2章才开始涉及一些非常简单的编程任务。我希望第0章和第1章的铺垫能够为零基础的读者提供到一些实在的帮助。

当然，对初学者非常友善的C语言教材还是不少的。不过我还有一个目的，那就是希望能在有限的篇幅里面尽量做到授人以渔，讲透更多C语言背后的细节，能够回答更多本质性的问题，而非仅仅是对代码功能的罗列。把语法的正式定义大幅简化，并且进行讲解就是我为了这个目标的尝试之一。

&nbsp;

语法的正式定义为什么重要？它能够为你解释很多看似复杂难懂的语法现象。这里举一个小例子：之前有人在学校里学习了一年的C语言，拿着一道练习题问我：

> ```c
> typedef int *type1;
> int *a,b;
> type1 c,d;
> ```
>
> 为什么a，c，d都是指针但是b就是变量？

我脑袋中立马浮现出了答案：

因为第一个声明中，int是*declaration-specifiers*，\*a和b各自是独立的*declarator*，a是*direct-declarator*且是*identifier*，前面的星号即*pointer*，最终使a成为int类型的指针；而b就直接是int类型的变量；而第二个声明中，之前用typedef将type1定义为int \*类型，因此拿着type1当作*declaration-specifiers*，会使得c和d都变成了两个int \*类型的变量。

不过我转念一想，我要是这样说出来，岂不是先要花半个小时给对方讲解一下语法的定义，才能够把这个问题讲明白？所以最后想了好一会儿采用了一种折中但是不严谨的讲法：因为默认情况下星号和后面的a而非前面的int结合得更紧密一些，于是b就没有被影响到，但是typedef就强行改变了星号的结合顺序，导致c和d都是指针。

不过如果对方已经学过语法，这个问题就可以得到透彻的讲解。而且面对新的语法问题也可以举一反三。

&nbsp;

当然，即使你对我讲解的所有内容都完全掌握，也就算C语言刚刚入门。还需要很多很多内容需要学习。

&nbsp;

### 之后的内容&给自学者的建议

这个教材现在的内容基本完善，但是有一些坑没有填。

&nbsp;

第一个大坑是printf和scanf：

printf既然叫做格式化输出，它对于格式的控制是非常强大的，我们仅仅学习了最为基础的输出能力。关于scanf，我们几乎只是讲解了scanf("%d",&a);这种最为基本的用法，你有没有想过如果写入scanf("%d\\n",&a);或者scanf("%d,%d",&a,&b);会发生什么？你有没有想过如果你在需要%d的时候输入了一个字母会发生什么？这些现象及其复杂，本质上都是背后缓存区的效果。如果要仔细研究，实际上可以占用一个章节的篇幅。

&nbsp;

另外一个是关于表达式语句的高级应用：

有一些表达式语句看似简单，但是能实现的功能实际上非常强大。例如说

```c
while(scanf("%d",&a[i++]));
//或者
*ptr1++=*ptr2++;
```

这些运算符凑在一起，可以让程序能够在非常简短的代码中实现非常强大的功能。如果学会，代码将会进一步提升简洁性，因为其概念比较复杂，因此需要新开一章进行讲解。

&nbsp;

然后就是关于算法的初步介绍：

目前我们做的所有事情，都是学习C语言这个工具，确保它不会在使用的时候猛然砸到你的脚，或者说根本不听指挥。但是学习计算机编程最为本质的行为是解决问题，而算法，就是独立于一门特定的编程语言，用系统性的思路来研究、解决、优化问题的学问。学了算法后，在面对陌生的问题时，你可以找到对应的思路启发，并且不断优化效率。

&nbsp;

还有的内容有，标准库stdlib.h，string.h等等的使用，预处理器的使用，文件的写入的读取等等...

&nbsp;

本书后面计划的大纲中有如上的内容。但是平心而论，后面那些内容的讲解并不是本书的强项。我的目标是能够在尽量少的篇幅里面为读者展示出C语言的学习思路，为零基础初学者提供尽可能多的帮助。而走到这一步，读者应当已经不算是零基础，后面的内容主要就是详尽而全面的列举，几乎不涉及到什么核心的思路。

而在这一点上，已经有很多优秀的教材，因此我也在犹豫之后的章节应该如何讲解，以什么难度进行讲解。正好在这个时候，我有另外的事情要做，这个教材也在走到了一个暂时的完结点。因此、后面进阶篇和深入篇的内容将会不定期推出，仍然会以那种简明易懂的语言对相关话题进行讲解。如果在你阅读本书的时候，后面的章节已经发布，你可以按照你个人的喜好选择阅读，毕竟C语言的内容本身是固定的，那些内容会和大多数教材相似。

&nbsp;

对于学完本教材基础篇，仍然想要接触C语言的自学者，我强烈建议你去看一看《C Primer Plus》去掌握那些被我裁剪掉的细节，然后再去看看《C与指针》去深究一下，然后针对自己的需求，再去扩展算法、C的新标准等相关的教材。这个时候你再去读那些书，则能够理解其中的大多数内容，学习就变得更加顺畅。如果你想要更多的编程练习，你可以去Leetcode这种优秀的平台去找更多的编程题进行练习。

&nbsp;

祝愿各位在今后的工作与生活中、能够领略更多编程世界的乐趣。

------

作者 - Author: Thomas Yao

GitHub名 - GitHub username: [hypergraphUniverse](https://github.com/hypergraphUniverse)

联系作者邮箱 - Email：hypergraphUniverse@outlook.com

![](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png)

除非另有说明或授权，本文档中的内容，包括但不限于文字以及原创图片按照[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)协议发布。请在遵守协议的情况下使用本文档，请注意下方对某些情况的法律提醒，**尤其**是在各类**自媒体平台上转发**的说明。请适当且明显地标注出处。

This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy of this license, visit [http://creativecommons.org/licenses/by-nc-sa/4.0/](http://creativecommons.org/licenses/by-nc-sa/4.0/) or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA. Please indicate the source clearly and appropriately when using. 

&nbsp;

法律提醒：

CC协议对于作品的转载与使用的约束相较于传统版权较为宽松，但是您仍然需要在使用的时候严格遵守协议，充分尊重版权。下面的文字，提供了详细的解释，希望您能够阅读后注意。如果如下文本的解释与原[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)协议有出入，请以原协议解释为准。

&nbsp;

本协议允许您对于本作品进行使用以及改编，但是您需要在使用、改编、再发布的过程中遵守以下的要求：

1. **保留著名权**。您使用本作品的行为必须给出适当的**原作者署名**，以及提供指向**本许可协议的链接**，同时**标明是否**对原始作品作了**修改**。

   适当的著名包括但不限于原作者的名字，以及指向原作品的链接等。这里建议您在转载过程中，至少要加入如上的两个原作者信息。且请您务必在显著的位置上进行原作者著名。

2. **非商用**。您不得将本作品以及基于本作品的改编内容用于商用目的。

   需要注意的是，商用目的**并非仅仅意味着获得金钱**的收入，在转发到自媒体平台上时尤其需要注意，详情参见后面的注意事项。

3. **遵守同协议**。如果您再混合、转换或者基于本作品进行创作，您必须**基于与原先许可协议相同的许可协议**分发您贡献的作品。

   您可以在Common Creative官网上找到和CC BY-NC-SA 4.0相兼容的协议。

&nbsp;

您需要注意的一些事情：

1. 非商用（NC）的限制并非仅意味着直接的金钱收入，商用的含义包括了直接或者非直接获得利益。

   很明显，在没有原作者的授权下，您**不能**将作为**收费文章**转发，否则违反了本协议；如果您将本文章以免费文章的形式转发于某种形式的自媒体，其获得的**观众打赏，流量分成或者广告分成**仍然属于一种商业利益，其也是违反非商业限制的；即使您关闭掉了所有的收益功能，未从中获得任何直接的金钱利益，您仍然有利用本文章**提高您知名度**的嫌疑，其也会被视作一种商业利益。即使最终本作品未给您带来任何实际的流量，您实际上已违反了本协议。

   上述的案例尤其适用于微信、微博或者其他社交传媒平台上，以盈利或引流为目的而创立、运营的帐号。

   如果您将本作品进行**改编**，例如制作成视频，将其发布在任一平台上，您仍然面对如上相同的情况。且改编人不得不面对SA条款带来的更多约束。

   &nbsp;

2. 在和**原作者的协商和正式约定**下，您可以按照新的约定，将本作品进行使用，包括商业使用。这相当于您单独从原作者手中获得了另一份使用协议。由于CC协议是一种许可协议而非限制协议，所以两者是不冲突的。

   &nbsp;

3. **如果您违反了本协议**，那么您获得的CC**许可证书**将立即**自动终止**。按照4.0协议，您有30天的窗口期可以修复您的失误以重新使得CC许可证书生效。

   如果您手上的CC许可证书因为您违反协议的行为而失效，您对于本作品的使用则是**无授权的，是侵权行为**。按照《中华人民共和国著作权法》，您会被追究责任，会面临**撤回侵权内容、公开致歉、补偿稿费**等合法要求。需要注意的是，30天的窗口期恢复证书仅仅在少量情况发挥作用，例如我在这30天中取消了所有获得本作品的途径，您可以通过窗口期重新获得协议而不需要重新授权。在您未恢复您的失误前，您手上的CC许可证书依然是无效的，将面临被追究法律责任的风险。

   请您不要冒险，如果我发现**未授权的行为**，将会及时固定证据链，并且**从重追究**。

&nbsp;

综合1,2,3可以看出来，对于各类公众平台或自媒体的转发或者改编，都有违反本协议NC条款的风险，而这是极其容易发生的。但如果您获得了新的授权，则完全不需要产生类似的担忧，因此强烈建议您在转发的时候联系原作者获得转发的授权。

&nbsp;

我采用CC协议的一个初衷就是希望更多的人能够从中学习到知识，让知识能够更加轻松地共享出去，CC协议保障了阅读者自由使用它的权力。在此之上，我对于本作品的传播自然是欢迎的，而且我也欢迎有人能够将其改编为视频。对NC和SA条款的保留，主要是我不希望自己接近于无偿的工作被其他人直接当作获得各种利益的手段。

