/*
有一个活动需要收集一群人的工号(工号长度不会超过int类型数字的容量，关于数据超界你不需要做检测)。
但是糟糕的组织管理导致数据被从很多渠道里收集了很多遍，且每一个渠道的信息都不是完整的。
于是最后你获得的名单中有很多重复数据。

现在希望编写一个程序，将重复出现的数据剔除，这一串数据最后用0表示输入结束。
你不需要也不能改变原有表的顺序。输入数据表格中不包括结尾0的数据长度不会超过100项。

|       | 输入                                  | 输出                    |
| ----- | ------------------------------------- | ----------------------- |
| 案例1 | 12345 12346 12346 12347 12345 0       | 12345 12346 12347       |
| 案例2 | 333 111 222 222 111 999 777 222 444 0 | 333 111 222 999 777 444 |

这里有排版美观问题因此输出安排在了一行中。你的输出中，输出一个工号之后使用换行\n进行分割。

额外思考：如果说限制条件变成，最后不重复的数据不会超过100项。
对于输入的表格数据长度未做限制，你的程序还能保证稳定运行吗？
如果不行，能不能做出改进呢？
*/ 
#include<stdio.h>
int main(void){
	int id[100];
	int num=0;
	
	while(1){
		scanf("%d",&id[num]);
		if(id[num]==0){
			break;
		}
		num++;
	}
	//需要注意的是，num最终的角标所在的数据是0，之后不需要使用到他
	
	for(int counter=0;counter<num;counter++){
		for(int i=0;i<counter;i++){
			if(id[counter]==id[i]){
				goto no_output;                  //因为要跳出两层for，所以使用goto，也不必投鼠忌器。 
			}                                    //实际上也可以改编为不用goto，需要加入一个判断是否存在的变量，多了一个变量和几行代码。 
		}
		printf("%d\n",id[counter]);
		no_output:; 
	}
	
	return 0;
} 
