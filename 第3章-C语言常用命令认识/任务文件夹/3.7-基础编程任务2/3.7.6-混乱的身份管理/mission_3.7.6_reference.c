/*
有一个活动需要收集一群人的工号(工号长度不会超过int类型数字的容量，关于数据超界你不需要做检测)。
但是糟糕的组织管理导致数据被从很多渠道里收集了很多遍，且每一个渠道的信息都不是完整的。
于是最后你获得的名单中有很多重复数据。

现在希望编写一个程序，将重复出现的数据剔除，这一串数据最后用0表示输入结束。
你不需要也不能改变原有表的顺序。输入数据表格中不包括结尾0的数据长度不会超过100项。

|       | 输入                                  | 输出                    |
| ----- | ------------------------------------- | ----------------------- |
| 案例1 | 12345 12346 12346 12347 12345 0       | 12345 12346 12347       |
| 案例2 | 333 111 222 222 111 999 777 222 444 0 | 333 111 222 999 777 444 |

这里有排版美观问题因此输出安排在了一行中。你的输出中，输出一个工号之后使用换行\n进行分割。

额外思考：如果说限制条件变成，最后不重复的数据不会超过100项。
对于输入的表格数据长度未做限制，你的程序还能保证稳定运行吗？
如果不行，能不能做出改进呢？
*/ 
#include<stdio.h>
int main(void){
	int id[100];
	int num=0;
	
	while(1){
		scanf("%d",&id[num]);
		if(id[num]==0){
			break;
		}
		num++;
	}
	//需要注意的是，num最终的角标所在的数据是0，之后不需要使用到他
	
	for(int counter=0;counter<num;counter++){
		int first=0;                                 
		while(id[first]!=id[counter]){              //查找第一次出现的，和counter位置数字相同的位置first 
			first++;
		}
		if(first==counter){                         //如果这个角标一致，则说明这个数字第一次出现，前面没有和他一样的数字，输出 
			printf("%d\n",id[counter]);             //如果不一致，说明前面有一个和自己一样的数字，则不输出 
		}
	}                                               //这种方式减少了对比，而且还不去使用goto，是一个非常精妙的思路，和标兵查找是一样的想法 
	
	return 0;
} 
