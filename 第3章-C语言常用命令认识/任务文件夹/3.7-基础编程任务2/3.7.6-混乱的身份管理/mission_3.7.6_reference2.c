/*
有一个活动需要收集一群人的工号(工号长度不会超过int类型数字的容量，关于数据超界你不需要做检测)。
但是糟糕的组织管理导致数据被从很多渠道里收集了很多遍，且每一个渠道的信息都不是完整的。
于是最后你获得的名单中有很多重复数据。

现在希望编写一个程序，将重复出现的数据剔除，这一串数据最后用0表示输入结束。
你不需要也不能改变原有表的顺序。输入数据表格中不包括结尾0的数据长度不会超过100项。

|       | 输入                                  | 输出                    |
| ----- | ------------------------------------- | ----------------------- |
| 案例1 | 12345 12346 12346 12347 12345 0       | 12345 12346 12347       |
| 案例2 | 333 111 222 222 111 999 777 222 444 0 | 333 111 222 999 777 444 |

这里有排版美观问题因此输出安排在了一行中。你的输出中，输出一个工号之后使用换行\n进行分割。

额外思考：如果说限制条件变成，最后不重复的数据不会超过100项。
对于输入的表格数据长度未做限制，你的程序还能保证稳定运行吗？
如果不行，能不能做出改进呢？
*/ 
#include<stdio.h>
int main(void){
	int id[100];
	int num=0,temp;
	
	//这个在输入过程中就检查了是否重复，因此可以满足额外思考的思路。而且实际上这个代码更加紧凑。 
	while(1){
		scanf("%d",&temp);
		if(temp==0){                //如果为0跳出循环 
			break;
		} 
		for(int i=0;i<=num;i++){    //检查是否有重复值，如果有，则不收录此值 
			if(temp==id[i]){
				goto no_collect;
			}
		}
		id[num]=temp;               //收录此值 
		num++;
		no_collect:;
	}
	
	for(int i;i<num;i++){
		printf("%d\n",id[i]); 
	}
	
	return 0;
} 
